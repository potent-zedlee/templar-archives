import {
  logger
} from "../../../../../../../../chunk-5LBG7BWZ.mjs";
import {
  execOptionsForRuntime,
  execPathForRuntime
} from "../../../../../../../../chunk-VJHIOLI5.mjs";
import {
  VERSION
} from "../../../../../../../../chunk-K5HZVWWG.mjs";
import {
  ApiBranchListResponseBody,
  BuildManifest,
  CreateAuthorizationCodeResponseSchema,
  CreateBackgroundWorkerResponse,
  DevConfigResponseBody,
  DevDequeueResponseBody,
  EnvironmentVariableResponseBody,
  EventSource,
  FailDeploymentResponseBody,
  GenerateRegistryCredentialsResponseBody,
  GetDeploymentResponseBody,
  GetEnvironmentVariablesResponseBody,
  GetJWTResponse,
  GetLatestDeploymentResponseBody,
  GetOrgsResponseBody,
  GetPersonalAccessTokenResponseSchema,
  GetProjectEnvResponse,
  GetProjectResponseBody,
  GetProjectsResponseBody,
  GetWorkerByTagResponse,
  InitializeDeploymentResponseBody,
  PromoteDeploymentResponseBody,
  RemoteBuildProviderStatusResponseBody,
  StartDeploymentIndexingResponseBody,
  TaskIndexingImportError,
  TaskMetadataParseError,
  TriggerTaskResponse,
  UncaughtExceptionError,
  UpsertBranchResponseBody,
  WhoAmIResponseSchema,
  WorkersCreateResponseBody,
  WorkersListResponseBody,
  WorkloadHeartbeatResponseBody,
  WorkloadRunAttemptCompleteResponseBody,
  WorkloadRunAttemptStartResponseBody,
  WorkloadRunLatestSnapshotResponseBody,
  external_exports,
  indexerToWorkerMessages,
  o,
  parseMessageFromCatalog,
  serializeIndexingError,
  wrapZodFetch,
  zodfetchSSE
} from "../../../../../../../../chunk-TG35EUPA.mjs";
import "../../../../../../../../chunk-OC53RUFM.mjs";
import "../../../../../../../../chunk-2MN4AEM4.mjs";
import {
  __name,
  init_esm
} from "../../../../../../../../chunk-S766OV2E.mjs";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed-index-controller.js
init_esm();
import { readFile, writeFile } from "node:fs/promises";
import { join } from "node:path";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/apiClient.js
init_esm();
var CliApiClient = class {
  static {
    __name(this, "CliApiClient");
  }
  apiURL;
  accessToken;
  branch;
  engineURL;
  constructor(apiURL, accessToken, branch) {
    this.apiURL = apiURL;
    this.accessToken = accessToken;
    this.branch = branch;
    this.apiURL = apiURL.replace(/\/$/, "");
    this.engineURL = this.apiURL;
    this.branch = branch;
  }
  async createAuthorizationCode() {
    return wrapZodFetch(CreateAuthorizationCodeResponseSchema, `${this.apiURL}/api/v1/authorization-code`, {
      method: "POST"
    });
  }
  async getPersonalAccessToken(authorizationCode) {
    return wrapZodFetch(GetPersonalAccessTokenResponseSchema, `${this.apiURL}/api/v1/token`, {
      method: "POST",
      body: JSON.stringify({
        authorizationCode
      })
    });
  }
  async whoAmI(projectRef) {
    if (!this.accessToken) {
      throw new Error("whoAmI: No access token");
    }
    const url = new URL("/api/v2/whoami", this.apiURL);
    if (projectRef) {
      url.searchParams.append("projectRef", projectRef);
    }
    return wrapZodFetch(WhoAmIResponseSchema, url.href, {
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json"
      }
    });
  }
  async retrieveExternals() {
    return wrapZodFetch(external_exports.object({ externals: external_exports.array(external_exports.string()) }), `https://jsonhero.io/j/GU7CwoDOL40k.json`, {
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
  async getProject(projectRef) {
    if (!this.accessToken) {
      throw new Error("getProject: No access token");
    }
    return wrapZodFetch(GetProjectResponseBody, `${this.apiURL}/api/v1/projects/${projectRef}`, {
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json"
      }
    });
  }
  async getProjects() {
    if (!this.accessToken) {
      throw new Error("getProjects: No access token");
    }
    return wrapZodFetch(GetProjectsResponseBody, `${this.apiURL}/api/v1/projects`, {
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json"
      }
    });
  }
  async getOrgs() {
    if (!this.accessToken) {
      throw new Error("getOrgs: No access token");
    }
    return wrapZodFetch(GetOrgsResponseBody, `${this.apiURL}/api/v1/orgs`, {
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json"
      }
    });
  }
  async createProject(orgParam, body) {
    if (!this.accessToken) {
      throw new Error("createProject: No access token");
    }
    return wrapZodFetch(GetProjectResponseBody, `${this.apiURL}/api/v1/orgs/${orgParam}/projects`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(body)
    });
  }
  async getWorkerByTag(projectRef, envName, tagName = "current") {
    if (!this.accessToken) {
      throw new Error("getWorkerByTag: No access token");
    }
    return wrapZodFetch(GetWorkerByTagResponse, `${this.apiURL}/api/v1/projects/${projectRef}/${envName}/workers/${tagName}`, {
      headers: this.getHeaders()
    });
  }
  async getJWT(projectRef, envName, body) {
    if (!this.accessToken) {
      throw new Error("getJWT: No access token");
    }
    return wrapZodFetch(GetJWTResponse, `${this.apiURL}/api/v1/projects/${projectRef}/${envName}/jwt`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(body)
    });
  }
  async getDevStatus(projectRef) {
    if (!this.accessToken) {
      throw new Error("getDevStatus: No access token");
    }
    return wrapZodFetch(external_exports.object({ isConnected: external_exports.boolean() }), `${this.apiURL}/api/v1/projects/${projectRef}/dev-status`, {
      headers: this.getHeaders()
    });
  }
  async createBackgroundWorker(projectRef, body) {
    if (!this.accessToken) {
      throw new Error("createBackgroundWorker: No access token");
    }
    return wrapZodFetch(CreateBackgroundWorkerResponse, `${this.apiURL}/api/v1/projects/${projectRef}/background-workers`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(body)
    });
  }
  async getProjectEnv({ projectRef, env }) {
    if (!this.accessToken) {
      throw new Error("getProjectDevEnv: No access token");
    }
    return wrapZodFetch(GetProjectEnvResponse, `${this.apiURL}/api/v1/projects/${projectRef}/${env}`, {
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json"
      }
    });
  }
  async upsertBranch(projectRef, body) {
    if (!this.accessToken) {
      throw new Error("upsertBranch: No access token");
    }
    return wrapZodFetch(UpsertBranchResponseBody, `${this.apiURL}/api/v1/projects/${projectRef}/branches`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
  }
  async archiveBranch(projectRef, branch) {
    if (!this.accessToken) {
      throw new Error("archiveBranch: No access token");
    }
    return wrapZodFetch(external_exports.object({ branch: external_exports.object({ id: external_exports.string() }) }), `${this.apiURL}/api/v1/projects/${projectRef}/branches/archive`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify({ branch })
    });
  }
  async listBranches(projectRef) {
    if (!this.accessToken) {
      throw new Error("listBranches: No access token");
    }
    return wrapZodFetch(ApiBranchListResponseBody, `${this.apiURL}/api/v1/projects/${projectRef}/branches`, {
      headers: this.getHeaders()
    });
  }
  async getEnvironmentVariables(projectRef) {
    if (!this.accessToken) {
      throw new Error("getEnvironmentVariables: No access token");
    }
    return wrapZodFetch(GetEnvironmentVariablesResponseBody, `${this.apiURL}/api/v1/projects/${projectRef}/envvars`, {
      headers: this.getHeaders()
    });
  }
  async importEnvVars(projectRef, slug, params) {
    if (!this.accessToken) {
      throw new Error("importEnvVars: No access token");
    }
    return wrapZodFetch(EnvironmentVariableResponseBody, `${this.apiURL}/api/v1/projects/${projectRef}/envvars/${slug}/import`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(params)
    });
  }
  async getRemoteBuildProviderStatus() {
    return wrapZodFetch(RemoteBuildProviderStatusResponseBody, `${this.apiURL}/api/v1/remote-build-provider-status`, {
      method: "GET",
      headers: {
        ...this.getHeaders(),
        // probably a good idea to add this to the other requests too
        "x-trigger-cli-version": VERSION
      }
    });
  }
  async generateRegistryCredentials(deploymentId) {
    if (!this.accessToken) {
      throw new Error("generateRegistryCredentials: No access token");
    }
    return wrapZodFetch(GenerateRegistryCredentialsResponseBody, `${this.apiURL}/api/v1/deployments/${deploymentId}/generate-registry-credentials`, {
      method: "POST",
      headers: this.getHeaders(),
      body: "{}"
    });
  }
  async initializeDeployment(body) {
    if (!this.accessToken) {
      throw new Error("initializeDeployment: No access token");
    }
    return wrapZodFetch(InitializeDeploymentResponseBody, `${this.apiURL}/api/v1/deployments`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(body)
    });
  }
  async createDeploymentBackgroundWorker(deploymentId, body) {
    if (!this.accessToken) {
      throw new Error("createDeploymentBackgroundWorker: No access token");
    }
    return wrapZodFetch(CreateBackgroundWorkerResponse, `${this.apiURL}/api/v1/deployments/${deploymentId}/background-workers`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(body)
    });
  }
  async failDeployment(id, body) {
    if (!this.accessToken) {
      throw new Error("failDeployment: No access token");
    }
    return wrapZodFetch(FailDeploymentResponseBody, `${this.apiURL}/api/v1/deployments/${id}/fail`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(body)
    });
  }
  async finalizeDeployment(id, body, onLog) {
    if (!this.accessToken) {
      throw new Error("finalizeDeployment: No access token");
    }
    let resolvePromise;
    const promise = new Promise((resolve) => {
      resolvePromise = resolve;
    });
    const source = zodfetchSSE({
      url: `${this.apiURL}/api/v3/deployments/${id}/finalize`,
      request: {
        method: "POST",
        headers: this.getHeaders(),
        body: JSON.stringify(body)
      },
      messages: {
        error: external_exports.object({ error: external_exports.string() }),
        log: external_exports.object({ message: external_exports.string() }),
        complete: FailDeploymentResponseBody
      }
    });
    source.onConnectionError((error) => {
      let message = error.message ?? "Unknown error";
      if (error.status !== void 0) {
        message = `HTTP ${error.status} ${message}`;
      }
      resolvePromise({
        success: false,
        error: message
      });
    });
    source.onMessage("complete", (message) => {
      resolvePromise({
        success: true,
        data: message
      });
    });
    source.onMessage("error", ({ error }) => {
      resolvePromise({
        success: false,
        error
      });
    });
    if (onLog) {
      source.onMessage("log", ({ message }) => {
        onLog(message);
      });
    }
    const result = await promise;
    source.stop();
    return result;
  }
  async promoteDeployment(version) {
    if (!this.accessToken) {
      throw new Error("promoteDeployment: No access token");
    }
    return wrapZodFetch(PromoteDeploymentResponseBody, `${this.apiURL}/api/v1/deployments/${version}/promote`, {
      method: "POST",
      headers: this.getHeaders()
    });
  }
  async startDeploymentIndexing(deploymentId, body) {
    if (!this.accessToken) {
      throw new Error("startDeploymentIndexing: No access token");
    }
    return wrapZodFetch(StartDeploymentIndexingResponseBody, `${this.apiURL}/api/v1/deployments/${deploymentId}/start-indexing`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(body)
    });
  }
  async getDeployment(deploymentId) {
    if (!this.accessToken) {
      throw new Error("getDeployment: No access token");
    }
    return wrapZodFetch(GetDeploymentResponseBody, `${this.apiURL}/api/v1/deployments/${deploymentId}`, {
      headers: this.getHeaders()
    });
  }
  async triggerTaskRun(taskId, body) {
    if (!this.accessToken) {
      throw new Error("triggerTaskRun: No access token");
    }
    return wrapZodFetch(TriggerTaskResponse, `${this.apiURL}/api/v1/tasks/${taskId}/trigger`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(body ?? {})
    });
  }
  get dev() {
    return {
      config: this.devConfig.bind(this),
      presenceConnection: this.devPresenceConnection.bind(this),
      dequeue: this.devDequeue.bind(this),
      sendDebugLog: this.devSendDebugLog.bind(this),
      getRunExecutionData: this.devGetRunExecutionData.bind(this),
      heartbeatRun: this.devHeartbeatRun.bind(this),
      startRunAttempt: this.devStartRunAttempt.bind(this),
      completeRunAttempt: this.devCompleteRunAttempt.bind(this),
      setEngineURL: this.setEngineURL.bind(this)
    };
  }
  get workers() {
    return {
      list: this.listWorkers.bind(this),
      create: this.createWorker.bind(this)
    };
  }
  get deployments() {
    return {
      unmanaged: {
        latest: this.getLatestUnmanagedDeployment.bind(this)
      }
    };
  }
  async getLatestUnmanagedDeployment() {
    if (!this.accessToken) {
      throw new Error("getLatestUnmanagedDeployment: No access token");
    }
    return wrapZodFetch(GetLatestDeploymentResponseBody, `${this.apiURL}/api/v1/deployments/latest`, {
      headers: this.getHeaders()
    });
  }
  async listWorkers() {
    if (!this.accessToken) {
      throw new Error("listWorkers: No access token");
    }
    return wrapZodFetch(WorkersListResponseBody, `${this.apiURL}/api/v1/workers`, {
      headers: this.getHeaders()
    });
  }
  async createWorker(options) {
    if (!this.accessToken) {
      throw new Error("createWorker: No access token");
    }
    return wrapZodFetch(WorkersCreateResponseBody, `${this.apiURL}/api/v1/workers`, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(options)
    });
  }
  async devConfig() {
    if (!this.accessToken) {
      throw new Error("devConfig: No access token");
    }
    return wrapZodFetch(DevConfigResponseBody, `${this.engineURL}/engine/v1/dev/config`, {
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accept: "application/json"
      }
    });
  }
  devPresenceConnection() {
    if (!this.accessToken) {
      throw new Error("connectToPresence: No access token");
    }
    let retryCount = 0;
    const maxRetries = 5;
    const retryDelay = 1e3;
    const eventSource = new EventSource(`${this.engineURL}/engine/v1/dev/presence`, {
      fetch: /* @__PURE__ */ __name((input, init) => fetch(input, {
        ...init,
        headers: {
          ...init?.headers,
          Authorization: `Bearer ${this.accessToken}`
        }
      }), "fetch")
    });
    eventSource.onopen = () => {
      logger.debug("Presence connection established");
      retryCount = 0;
    };
    eventSource.onerror = (error) => {
      logger.debug("Presence connection error, will automatically attempt to reconnect", {
        error,
        readyState: eventSource.readyState
      });
      if (eventSource.readyState === EventSource.CLOSED) {
        logger.debug("Presence connection permanently closed", { error, retryCount });
        if (retryCount < maxRetries) {
          retryCount++;
          const backoffDelay = retryDelay * Math.pow(2, retryCount - 1);
          logger.debug(`Attempting reconnection in ${backoffDelay}ms (attempt ${retryCount}/${maxRetries})`);
          eventSource.close();
          setTimeout(() => {
            this.devPresenceConnection();
          }, backoffDelay);
        } else {
          logger.debug("Max retry attempts reached, giving up");
        }
      }
    };
    return eventSource;
  }
  async devDequeue(body) {
    if (!this.accessToken) {
      throw new Error("devConfig: No access token");
    }
    return wrapZodFetch(DevDequeueResponseBody, `${this.engineURL}/engine/v1/dev/dequeue`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accept: "application/json"
      },
      body: JSON.stringify(body)
    });
  }
  async devSendDebugLog(runId, body) {
    if (!this.accessToken) {
      throw new Error("devConfig: No access token");
    }
    return wrapZodFetch(external_exports.unknown(), `${this.engineURL}/engine/v1/dev/runs/${runId}/logs/debug`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
  }
  async devGetRunExecutionData(runId) {
    return wrapZodFetch(WorkloadRunLatestSnapshotResponseBody, `${this.engineURL}/engine/v1/dev/runs/${runId}/snapshots/latest`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accept: "application/json"
      }
    });
  }
  async devHeartbeatRun(runId, snapshotId, body) {
    return wrapZodFetch(WorkloadHeartbeatResponseBody, `${this.engineURL}/engine/v1/dev/runs/${runId}/snapshots/${snapshotId}/heartbeat`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
  }
  async devStartRunAttempt(runId, snapshotId) {
    return wrapZodFetch(WorkloadRunAttemptStartResponseBody, `${this.engineURL}/engine/v1/dev/runs/${runId}/snapshots/${snapshotId}/attempts/start`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accept: "application/json"
      },
      //no body at the moment, but we'll probably add things soon
      body: JSON.stringify({})
    });
  }
  async devCompleteRunAttempt(runId, snapshotId, body) {
    return wrapZodFetch(WorkloadRunAttemptCompleteResponseBody, `${this.engineURL}/engine/v1/dev/runs/${runId}/snapshots/${snapshotId}/attempts/complete`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accept: "application/json"
      },
      body: JSON.stringify(body)
    });
  }
  setEngineURL(engineURL) {
    this.engineURL = engineURL.replace(/\/$/, "");
  }
  getHeaders() {
    const headers = {
      Authorization: `Bearer ${this.accessToken}`,
      "Content-Type": "application/json"
    };
    if (this.branch) {
      headers["x-trigger-branch"] = this.branch;
    }
    return headers;
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/indexing/indexWorkerManifest.js
init_esm();
import { fork } from "node:child_process";
async function indexWorkerManifest({ runtime, indexWorkerPath, buildManifestPath, nodeOptions, env: $env, cwd, otelHookInclude, otelHookExclude, handleStderr, handleStdout }) {
  return await new Promise((resolve, reject) => {
    let resolved = false;
    const child = fork(indexWorkerPath, {
      stdio: [
        /*stdin*/
        "ignore",
        /*stdout*/
        "pipe",
        /*stderr*/
        "pipe",
        "ipc"
      ],
      cwd,
      env: {
        ...$env,
        OTEL_IMPORT_HOOK_INCLUDES: otelHookInclude?.join(","),
        OTEL_IMPORT_HOOK_EXCLUDES: otelHookExclude?.join(","),
        TRIGGER_BUILD_MANIFEST_PATH: buildManifestPath,
        NODE_OPTIONS: nodeOptions,
        TRIGGER_INDEXING: "1"
      },
      execPath: execPathForRuntime(runtime)
    });
    const timeout = setTimeout(() => {
      if (resolved) {
        return;
      }
      resolved = true;
      child.kill("SIGKILL");
      reject(new Error("Worker timed out"));
    }, 2e4);
    child.on("message", async (msg) => {
      const message = parseMessageFromCatalog(msg, indexerToWorkerMessages);
      switch (message.type) {
        case "INDEX_COMPLETE": {
          clearTimeout(timeout);
          resolved = true;
          if (message.payload.importErrors.length > 0) {
            reject(new TaskIndexingImportError(message.payload.importErrors, message.payload.manifest));
          } else {
            resolve(message.payload.manifest);
          }
          child.kill("SIGKILL");
          break;
        }
        case "TASKS_FAILED_TO_PARSE": {
          clearTimeout(timeout);
          resolved = true;
          reject(new TaskMetadataParseError(message.payload.zodIssues, message.payload.tasks));
          child.kill("SIGKILL");
          break;
        }
        case "UNCAUGHT_EXCEPTION": {
          clearTimeout(timeout);
          resolved = true;
          reject(new UncaughtExceptionError(message.payload.error, message.payload.origin));
          child.kill("SIGKILL");
          break;
        }
      }
    });
    child.on("exit", (code) => {
      if (!resolved) {
        clearTimeout(timeout);
        resolved = true;
        reject(new Error(`Worker exited with code ${code}`));
      }
    });
    child.stdout?.on("data", (data) => {
      handleStdout?.(data.toString());
    });
    child.stderr?.on("data", (data) => {
      handleStderr?.(data.toString());
    });
  });
}
__name(indexWorkerManifest, "indexWorkerManifest");

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/utilities/sourceFiles.js
init_esm();
function resolveSourceFiles(sources, tasks) {
  const tasksGroupedByFile = {};
  for (const task of tasks) {
    if (!tasksGroupedByFile[task.filePath]) {
      tasksGroupedByFile[task.filePath] = [];
    }
    tasksGroupedByFile[task.filePath].push(task);
  }
  const taskFiles = [];
  for (const [filePath, source] of Object.entries(sources)) {
    const tasks2 = tasksGroupedByFile[filePath] ?? [];
    const taskIds = tasks2.map((task) => task.id);
    taskFiles.push({
      ...source,
      taskIds,
      filePath
    });
  }
  return taskFiles;
}
__name(resolveSourceFiles, "resolveSourceFiles");

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed-index-controller.js
async function loadBuildManifest() {
  const manifestContents = await readFile("./build.json", "utf-8");
  const raw = JSON.parse(manifestContents);
  return BuildManifest.parse(raw);
}
__name(loadBuildManifest, "loadBuildManifest");
async function bootstrap() {
  const buildManifest = await loadBuildManifest();
  if (typeof o.TRIGGER_API_URL !== "string") {
    console.error("TRIGGER_API_URL is not set");
    process.exit(1);
  }
  const cliApiClient = new CliApiClient(o.TRIGGER_API_URL, o.TRIGGER_SECRET_KEY, o.TRIGGER_PREVIEW_BRANCH);
  if (!o.TRIGGER_PROJECT_REF) {
    console.error("TRIGGER_PROJECT_REF is not set");
    process.exit(1);
  }
  if (!o.TRIGGER_DEPLOYMENT_ID) {
    console.error("TRIGGER_DEPLOYMENT_ID is not set");
    process.exit(1);
  }
  return {
    buildManifest,
    cliApiClient,
    projectRef: o.TRIGGER_PROJECT_REF,
    deploymentId: o.TRIGGER_DEPLOYMENT_ID
  };
}
__name(bootstrap, "bootstrap");
async function indexDeployment({ cliApiClient, projectRef, deploymentId, buildManifest }) {
  const stdout = [];
  const stderr = [];
  try {
    const $env = await cliApiClient.getEnvironmentVariables(projectRef);
    if (!$env.success) {
      throw new Error(`Failed to fetch environment variables: ${$env.error}`);
    }
    const workerManifest = await indexWorkerManifest({
      runtime: buildManifest.runtime,
      indexWorkerPath: buildManifest.indexWorkerEntryPoint,
      buildManifestPath: "./build.json",
      nodeOptions: execOptionsForRuntime(buildManifest.runtime, buildManifest),
      env: $env.data.variables,
      otelHookExclude: buildManifest.otelImportHook?.exclude,
      otelHookInclude: buildManifest.otelImportHook?.include,
      handleStdout(data) {
        stdout.push(data);
      },
      handleStderr(data) {
        if (!data.includes("DeprecationWarning")) {
          stderr.push(data);
        }
      }
    });
    console.log("Writing index.json", process.cwd());
    await writeFile(join(process.cwd(), "index.json"), JSON.stringify(workerManifest, null, 2));
    const sourceFiles = resolveSourceFiles(buildManifest.sources, workerManifest.tasks);
    const buildPlatform = process.env.BUILDPLATFORM;
    const targetPlatform = process.env.TARGETPLATFORM;
    const backgroundWorkerBody = {
      localOnly: true,
      metadata: {
        contentHash: buildManifest.contentHash,
        packageVersion: buildManifest.packageVersion,
        cliPackageVersion: buildManifest.cliPackageVersion,
        tasks: workerManifest.tasks,
        queues: workerManifest.queues,
        sourceFiles,
        runtime: workerManifest.runtime,
        runtimeVersion: workerManifest.runtimeVersion
      },
      engine: "V2",
      supportsLazyAttempts: true,
      buildPlatform,
      targetPlatform
    };
    const createResponse = await cliApiClient.createDeploymentBackgroundWorker(deploymentId, backgroundWorkerBody);
    if (!createResponse.success) {
      console.error(JSON.stringify({
        message: "Failed to create background worker",
        buildPlatform,
        targetPlatform,
        error: createResponse.error
      }));
      return;
    }
    console.log(JSON.stringify({
      message: "Background worker created",
      buildPlatform,
      targetPlatform,
      createResponse: createResponse.data
    }));
  } catch (error) {
    const serialiedIndexError = serializeIndexingError(error, stderr.join("\n"));
    console.error("Failed to index deployment", serialiedIndexError);
    await cliApiClient.failDeployment(deploymentId, { error: serialiedIndexError });
    process.exit(1);
  }
}
__name(indexDeployment, "indexDeployment");
var results = await bootstrap();
await indexDeployment(results);
//# sourceMappingURL=managed-index-controller.mjs.map
