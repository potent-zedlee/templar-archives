import {
  VERSION
} from "../../../../../../../../chunk-K5HZVWWG.mjs";
import {
  normalizeImportPath,
  require_source_map_support
} from "../../../../../../../../chunk-HC72UFVZ.mjs";
import {
  ZodIpcConnection
} from "../../../../../../../../chunk-HXM2E2KQ.mjs";
import {
  ConsoleInterceptor,
  DevUsageManager,
  ExecutorToWorkerMessageCatalog,
  OTEL_LOG_ATTRIBUTE_COUNT_LIMIT,
  OtelTaskLogger,
  PreciseWallClock,
  ProdUsageManager,
  SemanticInternalAttributes,
  SharedRuntimeManager,
  StandardHeartbeatsManager,
  StandardLifecycleHooksManager,
  StandardLocalsManager,
  StandardMetadataManager,
  StandardRealtimeStreamsManager,
  StandardResourceCatalog,
  StandardRunTimelineMetricsManager,
  StandardTraceContextManager,
  StandardWaitUntilManager,
  TaskExecutor,
  TaskRunContext,
  TaskRunErrorCodes,
  TracingSDK,
  UsageTimeoutManager,
  WorkerManifest,
  WorkerToExecutorMessageCatalog,
  apiClientManager,
  clock,
  getEnvVar,
  getNumberEnvVar,
  heartbeats,
  isCompleteTaskWithOutput,
  lifecycleHooks,
  localsAPI,
  logLevels,
  logger,
  o,
  populateEnv,
  promiseWithResolvers,
  realtimeStreams,
  recordSpanException,
  require_src,
  resourceCatalog,
  runMetadata,
  runTimelineMetrics,
  runtime,
  taskContext,
  timeout,
  traceContext,
  usage,
  waitUntil
} from "../../../../../../../../chunk-TG35EUPA.mjs";
import {
  SpanStatusCode,
  context,
  init_esm as init_esm2,
  trace
} from "../../../../../../../../chunk-OC53RUFM.mjs";
import "../../../../../../../../chunk-2MN4AEM4.mjs";
import {
  __name,
  __toESM,
  init_esm
} from "../../../../../../../../chunk-S766OV2E.mjs";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed-run-worker.js
init_esm();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/@trigger.dev/core/dist/esm/v3/tracer.js
init_esm();
init_esm2();
var import_api_logs = __toESM(require_src(), 1);
var TriggerTracer = class {
  static {
    __name(this, "TriggerTracer");
  }
  _config;
  constructor(_config) {
    this._config = _config;
  }
  _tracer;
  get tracer() {
    if (!this._tracer) {
      if ("tracer" in this._config)
        return this._config.tracer;
      this._tracer = trace.getTracer(this._config.name, this._config.version);
    }
    return this._tracer;
  }
  _logger;
  get logger() {
    if (!this._logger) {
      if ("logger" in this._config)
        return this._config.logger;
      this._logger = import_api_logs.logs.getLogger(this._config.name, this._config.version);
    }
    return this._logger;
  }
  startActiveSpan(name, fn, options, ctx, signal) {
    const parentContext = ctx ?? context.active();
    const attributes = options?.attributes ?? {};
    let spanEnded = false;
    const createPartialSpanWithEvents = options?.events && options.events.length > 0;
    return this.tracer.startActiveSpan(name, {
      ...options,
      attributes: {
        ...attributes,
        ...createPartialSpanWithEvents ? {
          [SemanticInternalAttributes.SKIP_SPAN_PARTIAL]: true
        } : {}
      },
      startTime: clock.preciseNow()
    }, parentContext, async (span) => {
      signal?.addEventListener("abort", () => {
        if (!spanEnded) {
          spanEnded = true;
          recordSpanException(span, signal.reason);
          span.end();
        }
      });
      if (taskContext.ctx && createPartialSpanWithEvents) {
        const partialSpan = this.tracer.startSpan(name, {
          ...options,
          attributes: {
            ...attributes,
            [SemanticInternalAttributes.SPAN_PARTIAL]: true,
            [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId
          }
        }, parentContext);
        if (options?.events) {
          for (const event of options.events) {
            partialSpan.addEvent(event.name, event.attributes, event.startTime);
          }
        }
        partialSpan.end();
      }
      if (options?.events) {
        for (const event of options.events) {
          span.addEvent(event.name, event.attributes, event.startTime);
        }
      }
      const usageMeasurement = usage.start();
      try {
        return await fn(span);
      } catch (e) {
        if (isCompleteTaskWithOutput(e)) {
          if (!spanEnded) {
            span.end(clock.preciseNow());
          }
          throw e;
        }
        if (!spanEnded) {
          if (typeof e === "string" || e instanceof Error) {
            span.recordException(e);
          }
          span.setStatus({ code: SpanStatusCode.ERROR });
        }
        throw e;
      } finally {
        if (!spanEnded) {
          spanEnded = true;
          if (taskContext.ctx) {
            const usageSample = usage.stop(usageMeasurement);
            const machine = taskContext.ctx.machine;
            span.setAttributes({
              [SemanticInternalAttributes.USAGE_DURATION_MS]: usageSample.cpuTime,
              [SemanticInternalAttributes.USAGE_COST_IN_CENTS]: machine?.centsPerMs ? usageSample.cpuTime * machine.centsPerMs : 0
            });
          }
          span.end(clock.preciseNow());
        }
      }
    });
  }
  startSpan(name, options, ctx) {
    const parentContext = ctx ?? context.active();
    const attributes = options?.attributes ?? {};
    const span = this.tracer.startSpan(name, options, parentContext);
    return span;
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed-run-worker.js
var import_source_map_support = __toESM(require_source_map_support(), 1);
import { readFile } from "node:fs/promises";
import { setTimeout } from "node:timers/promises";
import_source_map_support.default.install({
  handleUncaughtExceptions: false,
  environment: "node",
  hookRequire: false
});
process.on("uncaughtException", function(error, origin) {
  console.error("Uncaught exception", { error, origin });
  if (error instanceof Error) {
    process.send && process.send({
      type: "EVENT",
      message: {
        type: "UNCAUGHT_EXCEPTION",
        payload: {
          error: { name: error.name, message: error.message, stack: error.stack },
          origin
        },
        version: "v1"
      }
    });
  } else {
    process.send && process.send({
      type: "EVENT",
      message: {
        type: "UNCAUGHT_EXCEPTION",
        payload: {
          error: {
            name: "Error",
            message: typeof error === "string" ? error : JSON.stringify(error)
          },
          origin
        },
        version: "v1"
      }
    });
  }
});
var heartbeatIntervalMs = getEnvVar("HEARTBEAT_INTERVAL_MS");
var standardLocalsManager = new StandardLocalsManager();
localsAPI.setGlobalLocalsManager(standardLocalsManager);
var standardLifecycleHooksManager = new StandardLifecycleHooksManager();
lifecycleHooks.setGlobalLifecycleHooksManager(standardLifecycleHooksManager);
var standardRunTimelineMetricsManager = new StandardRunTimelineMetricsManager();
runTimelineMetrics.setGlobalManager(standardRunTimelineMetricsManager);
var standardResourceCatalog = new StandardResourceCatalog();
resourceCatalog.setGlobalResourceCatalog(standardResourceCatalog);
var durableClock = new PreciseWallClock();
clock.setGlobalClock(durableClock);
var standardTraceContextManager = new StandardTraceContextManager();
traceContext.setGlobalManager(standardTraceContextManager);
var runMetadataManager = new StandardMetadataManager(apiClientManager.clientOrThrow());
runMetadata.setGlobalManager(runMetadataManager);
var standardRealtimeStreamsManager = new StandardRealtimeStreamsManager(apiClientManager.clientOrThrow(), getEnvVar("TRIGGER_STREAM_URL", getEnvVar("TRIGGER_API_URL")) ?? "https://api.trigger.dev", (getEnvVar("TRIGGER_STREAMS_DEBUG") === "1" || getEnvVar("TRIGGER_STREAMS_DEBUG") === "true") ?? false);
realtimeStreams.setGlobalManager(standardRealtimeStreamsManager);
var waitUntilTimeoutInMs = getNumberEnvVar("TRIGGER_WAIT_UNTIL_TIMEOUT_MS", 6e4);
var waitUntilManager = new StandardWaitUntilManager(waitUntilTimeoutInMs);
waitUntil.setGlobalManager(waitUntilManager);
var standardHeartbeatsManager = new StandardHeartbeatsManager(parseInt(heartbeatIntervalMs ?? "30000", 10));
heartbeats.setGlobalManager(standardHeartbeatsManager);
var triggerLogLevel = getEnvVar("TRIGGER_LOG_LEVEL");
async function importConfig(configPath) {
  const configModule = await import(configPath);
  const config = configModule?.default ?? configModule?.config;
  return {
    config,
    handleError: configModule?.handleError
  };
}
__name(importConfig, "importConfig");
async function loadWorkerManifest() {
  const manifestContents = await readFile("./index.json", "utf-8");
  const raw = JSON.parse(manifestContents);
  return WorkerManifest.parse(raw);
}
__name(loadWorkerManifest, "loadWorkerManifest");
async function doBootstrap() {
  return await runTimelineMetrics.measureMetric("trigger.dev/start", "bootstrap", {}, async () => {
    const workerManifest = await loadWorkerManifest();
    resourceCatalog.registerWorkerManifest(workerManifest);
    const { config, handleError } = await importConfig(normalizeImportPath(workerManifest.configPath));
    const tracingSDK = new TracingSDK({
      url: o.TRIGGER_OTEL_EXPORTER_OTLP_ENDPOINT ?? "http://0.0.0.0:4318",
      instrumentations: config.instrumentations ?? [],
      diagLogLevel: o.TRIGGER_OTEL_LOG_LEVEL ?? "none",
      forceFlushTimeoutMillis: 3e4,
      exporters: config.telemetry?.exporters ?? [],
      logExporters: config.telemetry?.logExporters ?? []
    });
    const otelTracer = tracingSDK.getTracer("trigger-dev-worker", VERSION);
    const otelLogger = tracingSDK.getLogger("trigger-dev-worker", VERSION);
    const tracer = new TriggerTracer({ tracer: otelTracer, logger: otelLogger });
    const consoleInterceptor = new ConsoleInterceptor(otelLogger, typeof config.enableConsoleLogging === "boolean" ? config.enableConsoleLogging : true, typeof config.disableConsoleInterceptor === "boolean" ? config.disableConsoleInterceptor : false, OTEL_LOG_ATTRIBUTE_COUNT_LIMIT);
    const configLogLevel = triggerLogLevel ?? config.logLevel ?? "info";
    const otelTaskLogger = new OtelTaskLogger({
      logger: otelLogger,
      tracer,
      level: logLevels.includes(configLogLevel) ? configLogLevel : "info",
      maxAttributeCount: OTEL_LOG_ATTRIBUTE_COUNT_LIMIT
    });
    logger.setGlobalTaskLogger(otelTaskLogger);
    if (config.init) {
      lifecycleHooks.registerGlobalInitHook({
        id: "config",
        fn: config.init
      });
    }
    if (config.onStart) {
      lifecycleHooks.registerGlobalStartHook({
        id: "config",
        fn: config.onStart
      });
    }
    if (config.onSuccess) {
      lifecycleHooks.registerGlobalSuccessHook({
        id: "config",
        fn: config.onSuccess
      });
    }
    if (config.onFailure) {
      lifecycleHooks.registerGlobalFailureHook({
        id: "config",
        fn: config.onFailure
      });
    }
    if (handleError) {
      lifecycleHooks.registerGlobalCatchErrorHook({
        id: "config",
        fn: handleError
      });
    }
    return {
      tracer,
      tracingSDK,
      consoleInterceptor,
      config,
      workerManifest
    };
  });
}
__name(doBootstrap, "doBootstrap");
var bootstrapCache;
async function bootstrap() {
  if (!bootstrapCache) {
    bootstrapCache = await doBootstrap();
  }
  return bootstrapCache;
}
__name(bootstrap, "bootstrap");
var _execution;
var _isRunning = false;
var _isCancelled = false;
var _tracingSDK;
var _executionMeasurement;
var _cancelController = new AbortController();
var _lastFlushPromise;
var _sharedWorkerRuntime;
function resetExecutionEnvironment() {
  _execution = void 0;
  _isRunning = false;
  _isCancelled = false;
  _executionMeasurement = void 0;
  _cancelController = new AbortController();
  standardLocalsManager.reset();
  standardLifecycleHooksManager.reset();
  standardRunTimelineMetricsManager.reset();
  usage.reset();
  timeout.reset();
  runMetadataManager.reset();
  waitUntilManager.reset();
  standardRealtimeStreamsManager.reset();
  _sharedWorkerRuntime?.reset();
  durableClock.reset();
  taskContext.disable();
  standardTraceContextManager.reset();
  standardHeartbeatsManager.reset();
  waitUntil.register({
    requiresResolving: /* @__PURE__ */ __name(() => standardRealtimeStreamsManager.hasActiveStreams(), "requiresResolving"),
    promise: /* @__PURE__ */ __name((timeoutInMs) => standardRealtimeStreamsManager.waitForAllStreams(timeoutInMs), "promise")
  });
  console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Reset execution environment`);
}
__name(resetExecutionEnvironment, "resetExecutionEnvironment");
var _lastEnv;
var _executionCount = 0;
var zodIpc = new ZodIpcConnection({
  listenSchema: WorkerToExecutorMessageCatalog,
  emitSchema: ExecutorToWorkerMessageCatalog,
  process,
  handlers: {
    EXECUTE_TASK_RUN: /* @__PURE__ */ __name(async ({ execution, traceContext: traceContext2, metadata, metrics, env, isWarmStart }, sender) => {
      if (env) {
        populateEnv(env, {
          override: true,
          previousEnv: _lastEnv
        });
        _lastEnv = env;
      }
      console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Received EXECUTE_TASK_RUN isWarmStart ${String(isWarmStart)}`);
      if (_lastFlushPromise) {
        const now = performance.now();
        await _lastFlushPromise;
        const duration = performance.now() - now;
        console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Awaited last flush in ${duration}ms`);
      }
      resetExecutionEnvironment();
      standardTraceContextManager.traceContext = traceContext2;
      const prodManager = initializeUsageManager({
        usageIntervalMs: getEnvVar("USAGE_HEARTBEAT_INTERVAL_MS"),
        usageEventUrl: getEnvVar("USAGE_EVENT_URL"),
        triggerJWT: getEnvVar("TRIGGER_JWT")
      });
      prodManager.setInitialState({
        cpuTime: execution.run.durationMs ?? 0,
        costInCents: execution.run.costInCents ?? 0
      });
      standardRunTimelineMetricsManager.registerMetricsFromExecution(metrics, isWarmStart);
      console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Received EXECUTE_TASK_RUN`, execution);
      if (_isRunning) {
        console.error("Worker is already running a task");
        await sender.send("TASK_RUN_COMPLETED", {
          execution,
          result: {
            ok: false,
            id: execution.run.id,
            error: {
              type: "INTERNAL_ERROR",
              code: TaskRunErrorCodes.TASK_ALREADY_RUNNING
            },
            usage: {
              durationMs: 0
            },
            flushedMetadata: await runMetadataManager.stopAndReturnLastFlush()
          }
        });
        return;
      }
      const ctx = TaskRunContext.parse(execution);
      taskContext.setGlobalTaskContext({
        ctx,
        worker: metadata,
        isWarmStart: isWarmStart ?? false
      });
      try {
        const { tracer, tracingSDK, consoleInterceptor, config, workerManifest } = await bootstrap();
        _tracingSDK = tracingSDK;
        const taskManifest = workerManifest.tasks.find((t) => t.id === execution.task.id);
        if (!taskManifest) {
          console.error(`Could not find task ${execution.task.id}`);
          await sender.send("TASK_RUN_COMPLETED", {
            execution,
            result: {
              ok: false,
              id: execution.run.id,
              error: {
                type: "INTERNAL_ERROR",
                code: TaskRunErrorCodes.COULD_NOT_FIND_TASK,
                message: `Could not find task ${execution.task.id}. Make sure the task is exported and the ID is correct.`
              },
              usage: {
                durationMs: 0
              },
              flushedMetadata: await runMetadataManager.stopAndReturnLastFlush()
            }
          });
          return;
        }
        let task = resourceCatalog.getTask(execution.task.id);
        if (!task) {
          try {
            await runTimelineMetrics.measureMetric("trigger.dev/start", "import", {
              entryPoint: taskManifest.entryPoint,
              file: taskManifest.filePath
            }, async () => {
              const beforeImport = performance.now();
              resourceCatalog.setCurrentFileContext(taskManifest.entryPoint, taskManifest.filePath);
              if (workerManifest.initEntryPoint) {
                try {
                  await import(normalizeImportPath(workerManifest.initEntryPoint));
                  console.log(`Loaded init file from ${workerManifest.initEntryPoint}`);
                } catch (err) {
                  console.error(`Failed to load init file`, err);
                  throw err;
                }
              }
              await import(normalizeImportPath(taskManifest.entryPoint));
              resourceCatalog.clearCurrentFileContext();
              const durationMs = performance.now() - beforeImport;
              console.log(`Imported task ${execution.task.id} [${taskManifest.entryPoint}] in ${durationMs}ms`);
            });
          } catch (err) {
            console.error(`Failed to import task ${execution.task.id}`, err);
            await sender.send("TASK_RUN_COMPLETED", {
              execution,
              result: {
                ok: false,
                id: execution.run.id,
                error: {
                  type: "INTERNAL_ERROR",
                  code: TaskRunErrorCodes.COULD_NOT_IMPORT_TASK,
                  message: err instanceof Error ? err.message : String(err),
                  stackTrace: err instanceof Error ? err.stack : void 0
                },
                usage: {
                  durationMs: 0
                },
                flushedMetadata: await runMetadataManager.stopAndReturnLastFlush()
              }
            });
            return;
          }
          process.title = `trigger-dev-worker: ${execution.task.id} ${execution.run.id}`;
          task = resourceCatalog.getTask(execution.task.id);
        }
        if (!task) {
          console.error(`Could not find task ${execution.task.id}`);
          await sender.send("TASK_RUN_COMPLETED", {
            execution,
            result: {
              ok: false,
              id: execution.run.id,
              error: {
                type: "INTERNAL_ERROR",
                code: TaskRunErrorCodes.COULD_NOT_FIND_EXECUTOR
              },
              usage: {
                durationMs: 0
              },
              flushedMetadata: await runMetadataManager.stopAndReturnLastFlush()
            }
          });
          return;
        }
        runMetadataManager.runId = execution.run.id;
        runMetadataManager.runIdIsRoot = typeof execution.run.rootTaskRunId === "undefined";
        _executionCount++;
        const executor = new TaskExecutor(task, {
          tracer,
          tracingSDK,
          consoleInterceptor,
          retries: config.retries,
          isWarmStart,
          executionCount: _executionCount
        });
        try {
          _execution = execution;
          _isRunning = true;
          standardHeartbeatsManager.startHeartbeat(_execution.run.id);
          runMetadataManager.startPeriodicFlush(getNumberEnvVar("TRIGGER_RUN_METADATA_FLUSH_INTERVAL", 1e3));
          _executionMeasurement = usage.start();
          const timeoutController = timeout.abortAfterTimeout(execution.run.maxDuration);
          const signal = AbortSignal.any([_cancelController.signal, timeoutController.signal]);
          const { result } = await executor.execute(execution, ctx, signal);
          if (_isRunning && !_isCancelled) {
            const usageSample = usage.stop(_executionMeasurement);
            return sender.send("TASK_RUN_COMPLETED", {
              execution,
              result: {
                ...result,
                usage: {
                  durationMs: usageSample.cpuTime
                },
                flushedMetadata: await runMetadataManager.stopAndReturnLastFlush()
              }
            });
          }
        } finally {
          standardHeartbeatsManager.stopHeartbeat();
          _execution = void 0;
          _isRunning = false;
          console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Task run completed`);
        }
      } catch (err) {
        console.error("Failed to execute task", err);
        await sender.send("TASK_RUN_COMPLETED", {
          execution,
          result: {
            ok: false,
            id: execution.run.id,
            error: {
              type: "INTERNAL_ERROR",
              code: TaskRunErrorCodes.CONFIGURED_INCORRECTLY,
              message: err instanceof Error ? err.message : String(err),
              stackTrace: err instanceof Error ? err.stack : void 0
            },
            usage: {
              durationMs: 0
            },
            flushedMetadata: await runMetadataManager.stopAndReturnLastFlush()
          }
        });
      }
    }, "EXECUTE_TASK_RUN"),
    CANCEL: /* @__PURE__ */ __name(async ({ timeoutInMs }) => {
      _isCancelled = true;
      _cancelController.abort("run cancelled");
      await callCancelHooks(timeoutInMs);
      if (_executionMeasurement) {
        usage.stop(_executionMeasurement);
      }
      await flushAll(timeoutInMs);
    }, "CANCEL"),
    FLUSH: /* @__PURE__ */ __name(async ({ timeoutInMs }) => {
      await flushAll(timeoutInMs);
    }, "FLUSH"),
    RESOLVE_WAITPOINT: /* @__PURE__ */ __name(async ({ waitpoint }) => {
      _sharedWorkerRuntime?.resolveWaitpoints([waitpoint]);
    }, "RESOLVE_WAITPOINT")
  }
});
async function callCancelHooks(timeoutInMs = 1e4) {
  const now = performance.now();
  try {
    await Promise.race([lifecycleHooks.callOnCancelHookListeners(), setTimeout(timeoutInMs)]);
  } finally {
    const duration = performance.now() - now;
    console.log(`Called cancel hooks in ${duration}ms`);
  }
}
__name(callCancelHooks, "callCancelHooks");
async function flushAll(timeoutInMs = 1e4) {
  const now = performance.now();
  const { promise, resolve } = promiseWithResolvers();
  _lastFlushPromise = promise;
  const results = await Promise.allSettled([
    flushUsage(timeoutInMs),
    flushTracingSDK(timeoutInMs),
    flushMetadata(timeoutInMs)
  ]);
  const successfulFlushes = results.filter((result) => result.status === "fulfilled").map((result) => result.value.flushed);
  const failedFlushes = ["usage", "tracingSDK", "runMetadata"].filter((flushed) => !successfulFlushes.includes(flushed));
  if (failedFlushes.length > 0) {
    console.error(`Failed to flush ${failedFlushes.join(", ")}`);
  }
  const errorMessages = results.filter((result) => result.status === "rejected").map((result) => result.reason);
  if (errorMessages.length > 0) {
    console.error(errorMessages.join("\n"));
  }
  for (const flushed of successfulFlushes) {
    console.log(`Flushed ${flushed} successfully`);
  }
  const duration = performance.now() - now;
  console.log(`Flushed all in ${duration}ms`);
  resolve();
}
__name(flushAll, "flushAll");
async function flushUsage(timeoutInMs = 1e4) {
  const now = performance.now();
  await Promise.race([usage.flush(), setTimeout(timeoutInMs)]);
  const duration = performance.now() - now;
  console.log(`Flushed usage in ${duration}ms`);
  return {
    flushed: "usage",
    durationMs: duration
  };
}
__name(flushUsage, "flushUsage");
async function flushTracingSDK(timeoutInMs = 1e4) {
  const now = performance.now();
  await Promise.race([_tracingSDK?.flush(), setTimeout(timeoutInMs)]);
  const duration = performance.now() - now;
  console.log(`Flushed tracingSDK in ${duration}ms`);
  return {
    flushed: "tracingSDK",
    durationMs: duration
  };
}
__name(flushTracingSDK, "flushTracingSDK");
async function flushMetadata(timeoutInMs = 1e4) {
  const now = performance.now();
  await Promise.race([runMetadataManager.flush(), setTimeout(timeoutInMs)]);
  const duration = performance.now() - now;
  console.log(`Flushed runMetadata in ${duration}ms`);
  return {
    flushed: "runMetadata",
    durationMs: duration
  };
}
__name(flushMetadata, "flushMetadata");
function initializeUsageManager({ usageIntervalMs, usageEventUrl, triggerJWT }) {
  const devUsageManager = new DevUsageManager();
  const prodUsageManager = new ProdUsageManager(devUsageManager, {
    heartbeatIntervalMs: usageIntervalMs ? parseInt(usageIntervalMs, 10) : void 0,
    url: usageEventUrl,
    jwt: triggerJWT
  });
  usage.setGlobalUsageManager(prodUsageManager);
  timeout.setGlobalManager(new UsageTimeoutManager(devUsageManager));
  timeout.registerListener(async (maxDurationInSeconds, elapsedTimeInSeconds) => {
    console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Max duration exceeded: ${maxDurationInSeconds}s, elapsed: ${elapsedTimeInSeconds}s`);
    await zodIpc.send("MAX_DURATION_EXCEEDED", {
      maxDurationInSeconds,
      elapsedTimeInSeconds
    });
  });
  return prodUsageManager;
}
__name(initializeUsageManager, "initializeUsageManager");
_sharedWorkerRuntime = new SharedRuntimeManager(zodIpc, true);
runtime.setGlobalRuntimeManager(_sharedWorkerRuntime);
process.title = "trigger-managed-worker";
standardHeartbeatsManager.registerListener(async (id) => {
  await zodIpc.send("TASK_HEARTBEAT", { id });
});
console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Executor started`);
//# sourceMappingURL=managed-run-worker.mjs.map
