import {
  logger,
  source_default
} from "../../../../../../../../chunk-5LBG7BWZ.mjs";
import {
  execOptionsForRuntime,
  execPathForRuntime
} from "../../../../../../../../chunk-VJHIOLI5.mjs";
import {
  ZodIpcConnection
} from "../../../../../../../../chunk-HXM2E2KQ.mjs";
import {
  CancelledProcessError,
  CleanupProcessError,
  ExecutorToWorkerMessageCatalog,
  GracefulExitTimeoutError,
  IntervalService,
  MaxDurationExceededError,
  SimpleStructuredLogger,
  SuspendedProcessError,
  TaskRunErrorCodes,
  UnexpectedExitError,
  WORKLOAD_HEADERS,
  WarmStartClient,
  WorkerManifest,
  WorkerToExecutorMessageCatalog,
  WorkloadHttpClient,
  assertExhaustive,
  attemptKey,
  createSupportsColor,
  external_exports,
  flattenAttributes,
  init_supports_color,
  internalErrorFromUnexpectedExit,
  lookup,
  o,
  tryCatch,
  tryCatch2
} from "../../../../../../../../chunk-TG35EUPA.mjs";
import "../../../../../../../../chunk-OC53RUFM.mjs";
import "../../../../../../../../chunk-2MN4AEM4.mjs";
import {
  __commonJS,
  __export,
  __name,
  __toESM,
  init_esm
} from "../../../../../../../../chunk-S766OV2E.mjs";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/helper/index.js
var require_helper = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/helper/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/typeGuard.js
var require_typeGuard = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/typeGuard.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typeGuard = typeGuard;
    function typeGuard(value, isMatched) {
      return isMatched;
    }
    __name(typeGuard, "typeGuard");
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/interfaces/CtxLike.js
var require_CtxLike = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/interfaces/CtxLike.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CtxLike = void 0;
    var typeGuard_1 = require_typeGuard();
    var CtxLike;
    (function(CtxLike2) {
      function match(o3) {
        return (0, typeGuard_1.typeGuard)(o3, true) && o3 instanceof Object && typeof o3.done === "function" && typeof o3.abort === "function" && typeof o3.zz__addHandler === "function" && typeof o3.zz__removeHandler === "function";
      }
      __name(match, "match");
      CtxLike2.match = match;
    })(CtxLike = exports.CtxLike || (exports.CtxLike = {}));
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/interfaces/index.js
var require_interfaces = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/interfaces/index.js"(exports) {
    "use strict";
    init_esm();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k2];
        }, "get") };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o3[k22] = m[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CtxLike(), exports);
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/lib.dom.js
var require_lib_dom = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/lib.dom.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__hack = void 0;
    exports.__hack = "NOT TYPE ONLY";
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/EventTargetLike.js
var require_EventTargetLike = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/EventTargetLike.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventTargetLike = void 0;
    var typeGuard_1 = require_typeGuard();
    var EventTargetLike;
    (function(EventTargetLike2) {
      var RxJSSubject;
      (function(RxJSSubject2) {
        function match(eventTarget) {
          return (0, typeGuard_1.typeGuard)(eventTarget, true) && eventTarget instanceof Object && typeof eventTarget.subscribe === "function";
        }
        __name(match, "match");
        RxJSSubject2.match = match;
      })(RxJSSubject = EventTargetLike2.RxJSSubject || (EventTargetLike2.RxJSSubject = {}));
      var NodeStyleEventEmitter;
      (function(NodeStyleEventEmitter2) {
        ;
        function match(eventTarget) {
          return (0, typeGuard_1.typeGuard)(eventTarget, true) && eventTarget instanceof Object && typeof eventTarget.addListener === "function" && typeof eventTarget.removeListener === "function";
        }
        __name(match, "match");
        NodeStyleEventEmitter2.match = match;
      })(NodeStyleEventEmitter = EventTargetLike2.NodeStyleEventEmitter || (EventTargetLike2.NodeStyleEventEmitter = {}));
      var JQueryStyleEventEmitter;
      (function(JQueryStyleEventEmitter2) {
        function match(eventTarget) {
          return (0, typeGuard_1.typeGuard)(eventTarget, true) && eventTarget instanceof Object && typeof eventTarget.on === "function" && typeof eventTarget.off === "function";
        }
        __name(match, "match");
        JQueryStyleEventEmitter2.match = match;
      })(JQueryStyleEventEmitter = EventTargetLike2.JQueryStyleEventEmitter || (EventTargetLike2.JQueryStyleEventEmitter = {}));
      var HasEventTargetAddRemove;
      (function(HasEventTargetAddRemove2) {
        function match(eventTarget) {
          return (0, typeGuard_1.typeGuard)(eventTarget, true) && eventTarget instanceof Object && typeof eventTarget.addEventListener === "function" && typeof eventTarget.removeEventListener === "function";
        }
        __name(match, "match");
        HasEventTargetAddRemove2.match = match;
      })(HasEventTargetAddRemove = EventTargetLike2.HasEventTargetAddRemove || (EventTargetLike2.HasEventTargetAddRemove = {}));
      function canBe(o3) {
        try {
          return HasEventTargetAddRemove.match(o3) || NodeStyleEventEmitter.match(o3) || JQueryStyleEventEmitter.match(o3) || RxJSSubject.match(o3);
        } catch (_a) {
          return false;
        }
      }
      __name(canBe, "canBe");
      EventTargetLike2.canBe = canBe;
    })(EventTargetLike = exports.EventTargetLike || (exports.EventTargetLike = {}));
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/EvtError.js
var require_EvtError = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/EvtError.js"(exports) {
    "use strict";
    init_esm();
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d3[p] = b3[p];
        };
        return extendStatics(d2, b2);
      }, "extendStatics");
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        __name(__, "__");
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DetachedEvtError = exports.TimeoutEvtError = void 0;
    var TimeoutEvtError = (
      /** @class */
      function(_super) {
        __extends(TimeoutEvtError2, _super);
        function TimeoutEvtError2(timeout) {
          var _newTarget = this.constructor;
          var _this_1 = _super.call(this, "Evt timeout after ".concat(timeout, "ms")) || this;
          _this_1.timeout = timeout;
          Object.setPrototypeOf(_this_1, _newTarget.prototype);
          return _this_1;
        }
        __name(TimeoutEvtError2, "TimeoutEvtError");
        return TimeoutEvtError2;
      }(Error)
    );
    exports.TimeoutEvtError = TimeoutEvtError;
    var DetachedEvtError = (
      /** @class */
      function(_super) {
        __extends(DetachedEvtError2, _super);
        function DetachedEvtError2() {
          var _newTarget = this.constructor;
          var _this_1 = _super.call(this, "Evt handler detached") || this;
          Object.setPrototypeOf(_this_1, _newTarget.prototype);
          return _this_1;
        }
        __name(DetachedEvtError2, "DetachedEvtError");
        return DetachedEvtError2;
      }(Error)
    );
    exports.DetachedEvtError = DetachedEvtError;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/Operator.js
var require_Operator = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/Operator.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/index.js
var require_types = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/types/index.js"(exports) {
    "use strict";
    init_esm();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k2];
        }, "get") };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o3[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v });
    } : function(o3, v) {
      o3["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dom = void 0;
    __exportStar(require_helper(), exports);
    __exportStar(require_interfaces(), exports);
    exports.dom = __importStar(require_lib_dom());
    __exportStar(require_EventTargetLike(), exports);
    __exportStar(require_EvtError(), exports);
    __exportStar(require_Operator(), exports);
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/util/convertOperatorToStatelessFLambda.js
var require_convertOperatorToStatelessFLambda = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/util/convertOperatorToStatelessFLambda.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertOperatorToStatelessFλ = void 0;
    function encapsulateOpState(statefulFλOp) {
      var state = statefulFλOp[1];
      return function(data, registerSideEffect) {
        var opResult = statefulFλOp[0](data, state, registerSideEffect);
        if (opResult !== null) {
          registerSideEffect(function() {
            return state = opResult[0];
          });
        }
        return opResult;
      };
    }
    __name(encapsulateOpState, "encapsulateOpState");
    function statelessOpToStatelessFλ(op) {
      return function(data, registerSideEffect) {
        var opResult = op(data, registerSideEffect);
        return opResult instanceof Object && !("input" in opResult) && //exclude String.prototype.match
        opResult.length === 1 ? opResult : !!opResult ? [data] : null;
      };
    }
    __name(statelessOpToStatelessFλ, "statelessOpToStatelessFλ");
    function convertOperatorToStatelessFλ(op) {
      return typeof op !== "function" ? encapsulateOpState(op) : statelessOpToStatelessFλ(op);
    }
    __name(convertOperatorToStatelessFλ, "convertOperatorToStatelessFλ");
    exports.convertOperatorToStatelessFλ = convertOperatorToStatelessFλ;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/id.js
var require_id = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/id.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id = void 0;
    var id = /* @__PURE__ */ __name(function(x) {
      return x;
    }, "id");
    exports.id = id;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/util/compose.js
var require_compose = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/util/compose.js"(exports) {
    "use strict";
    init_esm();
    var __read = exports && exports.__read || function(o3, n) {
      var m = typeof Symbol === "function" && o3[Symbol.iterator];
      if (!m) return o3;
      var i = m.call(o3), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m = i["return"])) m.call(i);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compose = void 0;
    var convertOperatorToStatelessFLambda_1 = require_convertOperatorToStatelessFLambda();
    var id_1 = require_id();
    function f_o_g(op1, op2) {
      var opAtoB = (0, convertOperatorToStatelessFLambda_1.convertOperatorToStatelessFλ)(op1);
      var opBtoC = (0, convertOperatorToStatelessFLambda_1.convertOperatorToStatelessFλ)(op2);
      return (0, id_1.id)(function(dataA, registerSideEffect) {
        var resultB = opAtoB(dataA, registerSideEffect);
        if (!resultB) {
          return null;
        }
        var _a = __read(resultB, 1), dataB = _a[0];
        var resultC = opBtoC(dataB, registerSideEffect);
        if (!resultC) {
          return resultC;
        }
        return [resultC[0]];
      });
    }
    __name(f_o_g, "f_o_g");
    function compose() {
      var ops = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        ops[_i] = arguments[_i];
      }
      if (ops.length === 1) {
        var _a = __read(ops, 1), op = _a[0];
        return (0, convertOperatorToStatelessFLambda_1.convertOperatorToStatelessFλ)(op);
      }
      var _b = __read(ops), op1 = _b[0], op2 = _b[1], rest = _b.slice(2);
      var op1_o_op2 = f_o_g(op1, op2);
      if (rest.length === 0) {
        return op1_o_op2;
      }
      return compose.apply(void 0, __spreadArray([op1_o_op2], __read(rest), false));
    }
    __name(compose, "compose");
    exports.compose = compose;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/util/index.js
var require_util = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/util/index.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compose = void 0;
    var compose_1 = require_compose();
    Object.defineProperty(exports, "compose", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return compose_1.compose;
    }, "get") });
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/Map.js
var require_Map = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/Map.js"(exports) {
    "use strict";
    init_esm();
    exports.__esModule = true;
    exports.Polyfill = exports.LightMapImpl = void 0;
    var LightMapImpl = (
      /** @class */
      function() {
        function LightMapImpl2() {
          this.record = [];
        }
        __name(LightMapImpl2, "LightMapImpl");
        LightMapImpl2.prototype.has = function(key) {
          return this.record.map(function(_a) {
            var _key = _a[0];
            return _key;
          }).indexOf(key) >= 0;
        };
        LightMapImpl2.prototype.get = function(key) {
          var entry = this.record.filter(function(_a) {
            var _key = _a[0];
            return _key === key;
          })[0];
          if (entry === void 0) {
            return void 0;
          }
          return entry[1];
        };
        LightMapImpl2.prototype.set = function(key, value) {
          var entry = this.record.filter(function(_a) {
            var _key = _a[0];
            return _key === key;
          })[0];
          if (entry === void 0) {
            this.record.push([key, value]);
          } else {
            entry[1] = value;
          }
          return this;
        };
        LightMapImpl2.prototype["delete"] = function(key) {
          var index = this.record.map(function(_a) {
            var key2 = _a[0];
            return key2;
          }).indexOf(key);
          if (index < 0) {
            return false;
          }
          this.record.splice(index, 1);
          return true;
        };
        LightMapImpl2.prototype.keys = function() {
          return this.record.map(function(_a) {
            var key = _a[0];
            return key;
          });
        };
        return LightMapImpl2;
      }()
    );
    exports.LightMapImpl = LightMapImpl;
    exports.Polyfill = typeof Map !== "undefined" ? Map : LightMapImpl;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/Set.js
var require_Set = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/Set.js"(exports) {
    "use strict";
    init_esm();
    exports.__esModule = true;
    exports.Polyfill = exports.LightSetImpl = void 0;
    var Map_1 = require_Map();
    var LightSetImpl = (
      /** @class */
      function() {
        function LightSetImpl2(values) {
          this.map = new Map_1.Polyfill();
          if (values === void 0) {
            return;
          }
          for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            this.add(value);
          }
        }
        __name(LightSetImpl2, "LightSetImpl");
        LightSetImpl2.prototype.has = function(value) {
          return this.map.has(value);
        };
        LightSetImpl2.prototype.add = function(value) {
          this.map.set(value, true);
          return this;
        };
        LightSetImpl2.prototype.values = function() {
          return this.map.keys();
        };
        LightSetImpl2.prototype["delete"] = function(value) {
          return this.map["delete"](value);
        };
        return LightSetImpl2;
      }()
    );
    exports.LightSetImpl = LightSetImpl;
    exports.Polyfill = typeof Set !== "undefined" ? Set : LightSetImpl;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/WeakMap.js
var require_WeakMap = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/WeakMap.js"(exports) {
    "use strict";
    init_esm();
    exports.__esModule = true;
    exports.Polyfill = void 0;
    var Map_1 = require_Map();
    exports.Polyfill = typeof WeakMap !== "undefined" ? WeakMap : Map_1.Polyfill;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/assert.js
var require_assert = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/assert.js"(exports) {
    "use strict";
    init_esm();
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d3[p] = b3[p];
        };
        return extendStatics(d2, b2);
      }, "extendStatics");
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        __name(__, "__");
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssertionError = void 0;
    exports.assert = assert;
    exports.is = is;
    var AssertionError = (
      /** @class */
      function(_super) {
        __extends(AssertionError2, _super);
        function AssertionError2(msg) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, "Wrong assertion encountered" + (!msg ? "" : ': "'.concat(msg, '"'))) || this;
          _this.originalMessage = msg;
          Object.setPrototypeOf(_this, _newTarget.prototype);
          return _this;
        }
        __name(AssertionError2, "AssertionError");
        return AssertionError2;
      }(Error)
    );
    exports.AssertionError = AssertionError;
    var refOfIs = void 0;
    function assert(condition, msg) {
      if (arguments.length === 0) {
        condition = true;
      }
      if (refOfIs !== void 0) {
        refOfIs = void 0;
        return;
      }
      if (!condition) {
        var error = new AssertionError(typeof msg === "function" ? msg() : msg);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(error, assert);
        }
        throw error;
      }
    }
    __name(assert, "assert");
    var errorMessage = "Wrong usage of the `is` function refer to https://docs.tsafe.dev/is";
    function is(value) {
      var ref = {};
      if (refOfIs !== void 0) {
        refOfIs = void 0;
        throw new Error(errorMessage);
      }
      refOfIs = ref;
      Promise.resolve().then(function() {
        if (refOfIs === ref) {
          throw new Error(errorMessage);
        }
      });
      return null;
    }
    __name(is, "is");
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/lab/overwriteReadonlyProp.js
var require_overwriteReadonlyProp = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/lab/overwriteReadonlyProp.js"(exports) {
    "use strict";
    init_esm();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.overwriteReadonlyProp = overwriteReadonlyProp;
    function overwriteReadonlyProp(obj, propertyName, value) {
      try {
        obj[propertyName] = value;
      } catch (_a) {
      }
      if (obj[propertyName] === value) {
        return value;
      }
      var errorDefineProperty = void 0;
      var propertyDescriptor = Object.getOwnPropertyDescriptor(obj, propertyName) || {
        "enumerable": true,
        "configurable": true
      };
      if (!!propertyDescriptor.get) {
        throw new Error("Probably a wrong idea to overwrite ".concat(String(propertyName), " getter"));
      }
      try {
        Object.defineProperty(obj, propertyName, __assign(__assign({}, propertyDescriptor), { value }));
      } catch (error) {
        errorDefineProperty = error;
      }
      if (obj[propertyName] !== value) {
        throw errorDefineProperty || new Error("Can't assign");
      }
      return value;
    }
    __name(overwriteReadonlyProp, "overwriteReadonlyProp");
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/importProxy.js
var require_importProxy = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/importProxy.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importProxy = void 0;
    exports.importProxy = {};
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/LazyEvt.js
var require_LazyEvt = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/LazyEvt.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LazyEvt = void 0;
    var overwriteReadonlyProp_1 = require_overwriteReadonlyProp();
    var importProxy_1 = require_importProxy();
    var LazyEvt = (
      /** @class */
      function() {
        function LazyEvt2() {
          this.initialPostCount = 0;
        }
        __name(LazyEvt2, "LazyEvt");
        Object.defineProperty(LazyEvt2.prototype, "evt", {
          get: /* @__PURE__ */ __name(function() {
            if (this.__evt === void 0) {
              this.__evt = new importProxy_1.importProxy.Evt();
              (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(this.__evt, "postCount", this.initialPostCount);
            }
            return this.__evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        LazyEvt2.prototype.__post = function(data, doWait) {
          if (this.__evt === void 0) {
            return ++this.initialPostCount;
          }
          return this.__evt[doWait ? "postAndWait" : "post"](data);
        };
        LazyEvt2.prototype.post = function(data) {
          return this.__post(data, false);
        };
        LazyEvt2.prototype.postAndWait = function(data) {
          return this.__post(data, true);
        };
        return LazyEvt2;
      }()
    );
    exports.LazyEvt = LazyEvt;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Ctx.js
var require_Ctx = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Ctx.js"(exports) {
    "use strict";
    init_esm();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __values = exports && exports.__values || function(o3) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o3[s], i = 0;
      if (m) return m.call(o3);
      if (o3 && typeof o3.length === "number") return {
        next: /* @__PURE__ */ __name(function() {
          if (o3 && i >= o3.length) o3 = void 0;
          return { value: o3 && o3[i++], done: !o3 };
        }, "next")
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ctx = void 0;
    var Set_1 = require_Set();
    var WeakMap_1 = require_WeakMap();
    var assert_1 = require_assert();
    var LazyEvt_1 = require_LazyEvt();
    var importProxy_1 = require_importProxy();
    var overwriteReadonlyProp_1 = require_overwriteReadonlyProp();
    var CtxImpl = (
      /** @class */
      function() {
        function CtxImpl2() {
          this.lazyEvtAttach = new LazyEvt_1.LazyEvt();
          this.lazyEvtDetach = new LazyEvt_1.LazyEvt();
          this.lazyEvtDoneOrAborted = new LazyEvt_1.LazyEvt();
          this.handlers = new Set_1.Polyfill();
          this.evtByHandler = new WeakMap_1.Polyfill();
        }
        __name(CtxImpl2, "CtxImpl");
        Object.defineProperty(CtxImpl2.prototype, "evtDoneOrAborted", {
          get: /* @__PURE__ */ __name(function() {
            return this.lazyEvtDoneOrAborted.evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(CtxImpl2.prototype, "evtAttach", {
          get: /* @__PURE__ */ __name(function() {
            return this.lazyEvtAttach.evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(CtxImpl2.prototype, "evtDetach", {
          get: /* @__PURE__ */ __name(function() {
            return this.lazyEvtDetach.evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(CtxImpl2.prototype, "completionStatus", {
          get: /* @__PURE__ */ __name(function() {
            return this.__completionStatus;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        CtxImpl2.prototype.onDoneOrAborted = function(doneOrAborted) {
          this.__completionStatus = doneOrAborted;
          this.lazyEvtDoneOrAborted.post(doneOrAborted);
        };
        CtxImpl2.prototype.waitFor = function(timeout) {
          var _this_1 = this;
          return this.evtDoneOrAborted.waitFor(timeout).then(function(data) {
            if (data.type === "ABORTED") {
              throw data.error;
            }
            return data.result;
          }, function(timeoutError) {
            _this_1.abort(timeoutError);
            throw timeoutError;
          });
        };
        CtxImpl2.prototype.abort = function(error) {
          return this.__done(error);
        };
        CtxImpl2.prototype.done = function(result) {
          return this.__done(void 0, result);
        };
        CtxImpl2.prototype.__done = function(error, result) {
          var e_1, _a;
          var handlers = [];
          try {
            for (var _b = __values(this.handlers.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
              var handler = _c.value;
              var evt = this.evtByHandler.get(handler);
              var wasStillAttached = handler.detach();
              if (!wasStillAttached) {
                continue;
              }
              handlers.push({ handler, evt });
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          this.onDoneOrAborted(__assign(__assign({}, !!error ? { type: "ABORTED", error } : { type: "DONE", "result": result }), { handlers }));
          return handlers;
        };
        CtxImpl2.prototype.getHandlers = function() {
          var _this_1 = this;
          return Array.from(this.handlers.values()).map(function(handler) {
            return { handler, "evt": _this_1.evtByHandler.get(handler) };
          });
        };
        CtxImpl2.prototype.zz__addHandler = function(handler, evt) {
          (0, assert_1.assert)(handler.ctx === this);
          (0, assert_1.assert)((0, assert_1.is)(handler));
          if (this.completionStatus !== void 0) {
            handler.detach();
            return;
          }
          this.handlers.add(handler);
          this.evtByHandler.set(handler, evt);
          this.lazyEvtAttach.post({ handler, evt });
        };
        CtxImpl2.prototype.zz__removeHandler = function(handler) {
          (0, assert_1.assert)(handler.ctx === this);
          (0, assert_1.assert)((0, assert_1.is)(handler));
          this.lazyEvtDetach.post({
            handler,
            "evt": this.evtByHandler.get(handler)
          });
          this.handlers.delete(handler);
        };
        return CtxImpl2;
      }()
    );
    exports.Ctx = CtxImpl;
    try {
      (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(exports.Ctx, "name", "Ctx");
    } catch (_a) {
    }
    importProxy_1.importProxy.Ctx = exports.Ctx;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/Array.prototype.find.js
var require_Array_prototype_find = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/Array.prototype.find.js"(exports) {
    "use strict";
    init_esm();
    exports.__esModule = true;
    if (!Array.prototype.find) {
      Object.defineProperty(Array.prototype, "find", {
        value: /* @__PURE__ */ __name(function(predicate) {
          if (this == null) {
            throw new TypeError('"this" is null or not defined');
          }
          var o3 = Object(this);
          var len = o3.length >>> 0;
          if (typeof predicate !== "function") {
            throw new TypeError("predicate must be a function");
          }
          var thisArg = arguments[1];
          var k2 = 0;
          while (k2 < len) {
            var kValue = o3[k2];
            if (predicate.call(thisArg, kValue, k2, o3)) {
              return kValue;
            }
            k2++;
          }
          return void 0;
        }, "value"),
        configurable: true,
        writable: true
      });
    }
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.create.js
var require_Evt_create = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.create.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var importProxy_1 = require_importProxy();
    function create() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return args.length === 0 ? new importProxy_1.importProxy.Evt() : new importProxy_1.importProxy.StatefulEvt(args[0]);
    }
    __name(create, "create");
    exports.create = create;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.getCtx.js
var require_Evt_getCtx = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.getCtx.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCtxFactory = void 0;
    var WeakMap_1 = require_WeakMap();
    var importProxy_1 = require_importProxy();
    function getCtxFactory() {
      var ctxByObj = new WeakMap_1.Polyfill();
      function getCtx(obj) {
        var ctx = ctxByObj.get(obj);
        if (ctx === void 0) {
          ctx = new importProxy_1.importProxy.Ctx();
          ctxByObj.set(obj, ctx);
        }
        return ctx;
      }
      __name(getCtx, "getCtx");
      return getCtx;
    }
    __name(getCtxFactory, "getCtxFactory");
    exports.getCtxFactory = getCtxFactory;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.factorize.js
var require_Evt_factorize = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.factorize.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.factorize = void 0;
    function factorize(evt) {
      return evt;
    }
    __name(factorize, "factorize");
    exports.factorize = factorize;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.merge.js
var require_Evt_merge = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.merge.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = exports.mergeImpl = void 0;
    var importProxy_1 = require_importProxy();
    function mergeImpl(ctx, evts) {
      var evtUnion = new importProxy_1.importProxy.Evt();
      var callback = /* @__PURE__ */ __name(function(data) {
        return evtUnion.post(data);
      }, "callback");
      evts.forEach(function(evt) {
        if (ctx === void 0) {
          evt.attach(callback);
        } else {
          evt.attach(ctx, callback);
        }
      });
      return evtUnion;
    }
    __name(mergeImpl, "mergeImpl");
    exports.mergeImpl = mergeImpl;
    function merge(p1, p2) {
      return "length" in p1 ? mergeImpl(void 0, p1) : mergeImpl(p1, p2);
    }
    __name(merge, "merge");
    exports.merge = merge;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.from.js
var require_Evt_from = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.from.js"(exports) {
    "use strict";
    init_esm();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k2];
        }, "get") };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o3[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v });
    } : function(o3, v) {
      o3["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read = exports && exports.__read || function(o3, n) {
      var m = typeof Symbol === "function" && o3[Symbol.iterator];
      if (!m) return o3;
      var i = m.call(o3), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m = i["return"])) m.call(i);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.from = void 0;
    var id_1 = require_id();
    var assert_1 = require_assert();
    var typeGuard_1 = require_typeGuard();
    var Evt_merge_1 = require_Evt_merge();
    var importProxy_1 = require_importProxy();
    var nsEventTargetLike = __importStar(require_EventTargetLike());
    var EventTargetLikeAsValue = nsEventTargetLike.EventTargetLike;
    function fromImplForTargetEventLike(ctx, target, eventName, options) {
      var matchEventTargetLike = /* @__PURE__ */ __name(function(target_) {
        return EventTargetLikeAsValue.canBe(target_);
      }, "matchEventTargetLike");
      if (!matchEventTargetLike(target)) {
        if ("then" in target) {
          var evt_1 = new importProxy_1.importProxy.Evt();
          var isCtxDone_1 = function() {
            var getEvtDonePostCount = /* @__PURE__ */ __name(function() {
              return ctx === null || ctx === void 0 ? void 0 : ctx.evtDoneOrAborted.postCount;
            }, "getEvtDonePostCount");
            var n = getEvtDonePostCount();
            return function() {
              return n !== getEvtDonePostCount();
            };
          }();
          target.then(function(data) {
            if (isCtxDone_1()) {
              return;
            }
            evt_1.post(data);
          });
          return evt_1;
        }
        return (0, Evt_merge_1.mergeImpl)(ctx, Array.from(target).map(function(target2) {
          return fromImplForTargetEventLike(ctx, target2, eventName, options);
        }));
      }
      var proxy;
      if (EventTargetLikeAsValue.HasEventTargetAddRemove.match(target)) {
        proxy = {
          "on": /* @__PURE__ */ __name(function(listener2, eventName2, options2) {
            return target.addEventListener(eventName2, listener2, options2);
          }, "on"),
          "off": /* @__PURE__ */ __name(function(listener2, eventName2, options2) {
            return target.removeEventListener(eventName2, listener2, options2);
          }, "off")
        };
      } else if (EventTargetLikeAsValue.NodeStyleEventEmitter.match(target)) {
        proxy = {
          "on": /* @__PURE__ */ __name(function(listener2, eventName2) {
            return target.addListener(eventName2, listener2);
          }, "on"),
          "off": /* @__PURE__ */ __name(function(listener2, eventName2) {
            return target.removeListener(eventName2, listener2);
          }, "off")
        };
      } else if (EventTargetLikeAsValue.JQueryStyleEventEmitter.match(target)) {
        proxy = {
          "on": /* @__PURE__ */ __name(function(listener2, eventName2) {
            return target.on(eventName2, listener2);
          }, "on"),
          "off": /* @__PURE__ */ __name(function(listener2, eventName2) {
            return target.off(eventName2, listener2);
          }, "off")
        };
      } else if (EventTargetLikeAsValue.RxJSSubject.match(target)) {
        var subscription_1;
        proxy = {
          "on": /* @__PURE__ */ __name(function(listener2) {
            return subscription_1 = target.subscribe(function(data) {
              return listener2(data);
            });
          }, "on"),
          "off": /* @__PURE__ */ __name(function() {
            return subscription_1.unsubscribe();
          }, "off")
        };
      } else {
        (0, id_1.id)(target);
        (0, assert_1.assert)(false);
      }
      var evt = new importProxy_1.importProxy.Evt();
      var listener = /* @__PURE__ */ __name(function(data) {
        return evt.post(data);
      }, "listener");
      ctx === null || ctx === void 0 ? void 0 : ctx.evtDoneOrAborted.attachOnce(function() {
        return proxy.off(listener, eventName, options);
      });
      proxy.on(listener, eventName, options);
      return evt;
    }
    __name(fromImplForTargetEventLike, "fromImplForTargetEventLike");
    function fromImplForObserver(ctx, ObserverConstructor, target) {
      var evt = importProxy_1.importProxy.Evt.create();
      var listener = /* @__PURE__ */ __name(function(_a) {
        var _b = __read(_a, 1), entry = _b[0];
        return evt.post(entry);
      }, "listener");
      var observer = new ObserverConstructor(listener);
      observer.observe(target);
      ctx === null || ctx === void 0 ? void 0 : ctx.evtDoneOrAborted.attachOnce(function() {
        return observer.disconnect();
      });
      return evt;
    }
    __name(fromImplForObserver, "fromImplForObserver");
    function from(ctxOrTargetOrObserverConstructor, targetOrEventNameOrObserverConstructorOrObserverTarget, eventNameOrOptionsOrObserverTarget, options) {
      if ("evtDoneOrAborted" in ctxOrTargetOrObserverConstructor) {
        (0, assert_1.assert)((0, typeGuard_1.typeGuard)(targetOrEventNameOrObserverConstructorOrObserverTarget, true) && (0, typeGuard_1.typeGuard)(eventNameOrOptionsOrObserverTarget, true) && (0, typeGuard_1.typeGuard)(options, true));
        if (typeof targetOrEventNameOrObserverConstructorOrObserverTarget === "function") {
          (0, assert_1.assert)((0, typeGuard_1.typeGuard)(eventNameOrOptionsOrObserverTarget, true) && (0, typeGuard_1.typeGuard)(options, true));
          return fromImplForObserver(ctxOrTargetOrObserverConstructor, targetOrEventNameOrObserverConstructorOrObserverTarget, eventNameOrOptionsOrObserverTarget);
        } else {
          (0, assert_1.assert)((0, typeGuard_1.typeGuard)(eventNameOrOptionsOrObserverTarget, true));
          return fromImplForTargetEventLike(ctxOrTargetOrObserverConstructor, targetOrEventNameOrObserverConstructorOrObserverTarget, eventNameOrOptionsOrObserverTarget, options);
        }
      } else {
        (0, assert_1.assert)((0, typeGuard_1.typeGuard)(ctxOrTargetOrObserverConstructor, true) && (0, typeGuard_1.typeGuard)(targetOrEventNameOrObserverConstructorOrObserverTarget, true) && (0, typeGuard_1.typeGuard)(eventNameOrOptionsOrObserverTarget, true));
        if (typeof ctxOrTargetOrObserverConstructor === "function") {
          (0, assert_1.assert)((0, typeGuard_1.typeGuard)(targetOrEventNameOrObserverConstructorOrObserverTarget, true) && (0, typeGuard_1.typeGuard)(eventNameOrOptionsOrObserverTarget, true));
          return fromImplForObserver(void 0, ctxOrTargetOrObserverConstructor, targetOrEventNameOrObserverConstructorOrObserverTarget);
        } else {
          (0, assert_1.assert)((0, typeGuard_1.typeGuard)(targetOrEventNameOrObserverConstructorOrObserverTarget, true));
          return fromImplForTargetEventLike(void 0, ctxOrTargetOrObserverConstructor, targetOrEventNameOrObserverConstructorOrObserverTarget, eventNameOrOptionsOrObserverTarget);
        }
      }
    }
    __name(from, "from");
    exports.from = from;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.asPostable.js
var require_Evt_asPostable = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.asPostable.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asPostable = void 0;
    function asPostable(evt) {
      return evt;
    }
    __name(asPostable, "asPostable");
    exports.asPostable = asPostable;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.asyncPipe.js
var require_Evt_asyncPipe = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.asyncPipe.js"(exports) {
    "use strict";
    init_esm();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _3 = { label: 0, sent: /* @__PURE__ */ __name(function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, "sent"), trys: [], ops: [] }, f, y2, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_3) try {
          if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) return t;
          if (y2 = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _3.label++;
              return { value: op[1], done: false };
            case 5:
              _3.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _3.ops.pop();
              _3.trys.pop();
              continue;
            default:
              if (!(t = _3.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _3 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _3.label = op[1];
                break;
              }
              if (op[0] === 6 && _3.label < t[1]) {
                _3.label = t[1];
                t = op;
                break;
              }
              if (t && _3.label < t[2]) {
                _3.label = t[2];
                _3.ops.push(op);
                break;
              }
              if (t[2]) _3.ops.pop();
              _3.trys.pop();
              continue;
          }
          op = body.call(thisArg, _3);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asyncPipe = void 0;
    var importProxy_1 = require_importProxy();
    function asyncPipe(evt, asyncOp) {
      var _this_1 = this;
      var out = "state" in evt ? importProxy_1.importProxy.Evt.create(void 0) : importProxy_1.importProxy.Evt.create();
      var currentCallCount = 0;
      evt.attach(function(data) {
        return __awaiter(_this_1, void 0, void 0, function() {
          var thisCallCount, prOpResult, opResult;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                currentCallCount++;
                thisCallCount = currentCallCount;
                prOpResult = asyncOp(data);
                if (!(prOpResult !== null && "then" in prOpResult)) return [3, 2];
                return [4, prOpResult];
              case 1:
                opResult = _a.sent();
                if ("state" in evt && thisCallCount !== currentCallCount) {
                  return [
                    2
                    /*return*/
                  ];
                }
                return [3, 3];
              case 2:
                opResult = prOpResult;
                _a.label = 3;
              case 3:
                if (!opResult) {
                  return [
                    2
                    /*return*/
                  ];
                }
                out.post(opResult[0]);
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
      return out;
    }
    __name(asyncPipe, "asyncPipe");
    exports.asyncPipe = asyncPipe;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.asNonPostable.js
var require_Evt_asNonPostable = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.asNonPostable.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asNonPostable = void 0;
    function asNonPostable(evt) {
      return evt;
    }
    __name(asNonPostable, "asNonPostable");
    exports.asNonPostable = asNonPostable;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.parsePropsFromArgs.js
var require_Evt_parsePropsFromArgs = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.parsePropsFromArgs.js"(exports) {
    "use strict";
    init_esm();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __read = exports && exports.__read || function(o3, n) {
      var m = typeof Symbol === "function" && o3[Symbol.iterator];
      if (!m) return o3;
      var i = m.call(o3), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m = i["return"])) m.call(i);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parsePropsFromArgs = exports.matchAll = void 0;
    var id_1 = require_id();
    var compose_1 = require_compose();
    var typeGuard_1 = require_typeGuard();
    function matchAll() {
      return true;
    }
    __name(matchAll, "matchAll");
    exports.matchAll = matchAll;
    var canBeOperator = /* @__PURE__ */ __name(function(p) {
      return p !== void 0 && (0, typeGuard_1.typeGuard)(p, true) && (typeof p === "function" || typeof p[0] === "function");
    }, "canBeOperator");
    var defaultParams = {
      "op": matchAll,
      "ctx": void 0,
      "timeout": void 0,
      "callback": void 0
    };
    function parsePropsFromArgs(inputs, methodName) {
      switch (methodName) {
        case "pipe":
          {
            var getOpWrap = /* @__PURE__ */ __name(function(ops) {
              return ops.length === 0 ? {} : { "op": ops.length === 1 ? ops[0] : compose_1.compose.apply(void 0, __spreadArray([], __read(ops), false)) };
            }, "getOpWrap");
            if (canBeOperator(inputs[0])) {
              return (0, id_1.id)(__assign(__assign({}, defaultParams), getOpWrap(inputs)));
            } else {
              var _a = __read(inputs), ctx = _a[0], rest = _a.slice(1);
              return (0, id_1.id)(__assign(__assign(__assign({}, defaultParams), ctx !== void 0 ? { ctx } : {}), getOpWrap(rest)));
            }
          }
          break;
        case "waitFor":
          {
            return parsePropsFromArgs(__spreadArray(__spreadArray([], __read(inputs.filter(function(value, index) {
              return !(index === inputs.length - 1 && value === void 0);
            })), false), [
              defaultParams.callback
            ], false), "attach*");
          }
          break;
        case "attach*":
          {
            var n = inputs.length;
            switch (n) {
              case 4: {
                var _b = __read(inputs, 4), p1 = _b[0], p2 = _b[1], p3 = _b[2], p4 = _b[3];
                return (0, id_1.id)(__assign(__assign({}, defaultParams), { "op": p1, "ctx": p2, "timeout": p3, "callback": p4 }));
              }
              case 3: {
                var _c = __read(inputs, 3), p1 = _c[0], p2 = _c[1], p3 = _c[2];
                if (typeof p2 === "number") {
                  var timeout = p2;
                  var callback = p3;
                  if (canBeOperator(p1)) {
                    return (0, id_1.id)(__assign(__assign({}, defaultParams), { timeout, callback, "op": p1 }));
                  } else {
                    return (0, id_1.id)(__assign(__assign({}, defaultParams), { timeout, callback, "ctx": p1 }));
                  }
                } else {
                  return (0, id_1.id)(__assign(__assign({}, defaultParams), { "op": p1, "ctx": p2, "callback": p3 }));
                }
              }
              case 2: {
                var _d = __read(inputs, 2), p1 = _d[0], p2 = _d[1];
                if (typeof p1 === "number") {
                  return (0, id_1.id)(__assign(__assign({}, defaultParams), { "timeout": p1, "callback": p2 }));
                } else {
                  var callback = p2;
                  if (canBeOperator(p1)) {
                    return (0, id_1.id)(__assign(__assign({}, defaultParams), { callback, "op": p1 }));
                  } else {
                    return (0, id_1.id)(__assign(__assign({}, defaultParams), { callback, "ctx": p1 }));
                  }
                }
              }
              case 1: {
                var _e = __read(inputs, 1), p = _e[0];
                return (0, id_1.id)(__assign(__assign({}, defaultParams), { "callback": p }));
              }
              case 0: {
                return (0, id_1.id)(__assign({}, defaultParams));
              }
            }
          }
          break;
      }
    }
    __name(parsePropsFromArgs, "parsePropsFromArgs");
    exports.parsePropsFromArgs = parsePropsFromArgs;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.newCtx.js
var require_Evt_newCtx = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.newCtx.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newCtx = void 0;
    var importProxy_1 = require_importProxy();
    function newCtx() {
      return new importProxy_1.importProxy.Ctx();
    }
    __name(newCtx, "newCtx");
    exports.newCtx = newCtx;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/run-exclusive/lib/runExclusive.js
var require_runExclusive = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/run-exclusive/lib/runExclusive.js"(exports) {
    "use strict";
    init_esm();
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r2 = Array(s), k2 = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k2++)
          r2[k2] = a[j];
      return r2;
    };
    exports.__esModule = true;
    exports.buildMethodCb = exports.buildCb = exports.getPrComplete = exports.isRunning = exports.cancelAllQueuedCalls = exports.getQueuedCallCount = exports.buildMethod = exports.build = exports.createGroupRef = void 0;
    var WeakMap_1 = require_WeakMap();
    var ExecQueue = (
      /** @class */
      function() {
        function ExecQueue2() {
          this.queuedCalls = [];
          this.isRunning = false;
          this.prComplete = Promise.resolve();
        }
        __name(ExecQueue2, "ExecQueue");
        ExecQueue2.prototype.cancelAllQueuedCalls = function() {
          var n;
          this.queuedCalls.splice(0, n = this.queuedCalls.length);
          return n;
        };
        return ExecQueue2;
      }()
    );
    var globalContext = {};
    var clusters = new WeakMap_1.Polyfill();
    function getOrCreateExecQueue(context, groupRef) {
      var execQueueByGroup = clusters.get(context);
      if (!execQueueByGroup) {
        execQueueByGroup = new WeakMap_1.Polyfill();
        clusters.set(context, execQueueByGroup);
      }
      var execQueue = execQueueByGroup.get(groupRef);
      if (!execQueue) {
        execQueue = new ExecQueue();
        execQueueByGroup.set(groupRef, execQueue);
      }
      return execQueue;
    }
    __name(getOrCreateExecQueue, "getOrCreateExecQueue");
    function createGroupRef() {
      return new Array(0);
    }
    __name(createGroupRef, "createGroupRef");
    exports.createGroupRef = createGroupRef;
    function build() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      switch (inputs.length) {
        case 1:
          return buildFnPromise(true, createGroupRef(), inputs[0]);
        case 2:
          return buildFnPromise(true, inputs[0], inputs[1]);
      }
    }
    __name(build, "build");
    exports.build = build;
    function buildMethod() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      switch (inputs.length) {
        case 1:
          return buildFnPromise(false, createGroupRef(), inputs[0]);
        case 2:
          return buildFnPromise(false, inputs[0], inputs[1]);
      }
    }
    __name(buildMethod, "buildMethod");
    exports.buildMethod = buildMethod;
    function getQueuedCallCount(runExclusiveFunction, classInstanceObject) {
      var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);
      return execQueue ? execQueue.queuedCalls.length : 0;
    }
    __name(getQueuedCallCount, "getQueuedCallCount");
    exports.getQueuedCallCount = getQueuedCallCount;
    function cancelAllQueuedCalls(runExclusiveFunction, classInstanceObject) {
      var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);
      return execQueue ? execQueue.cancelAllQueuedCalls() : 0;
    }
    __name(cancelAllQueuedCalls, "cancelAllQueuedCalls");
    exports.cancelAllQueuedCalls = cancelAllQueuedCalls;
    function isRunning(runExclusiveFunction, classInstanceObject) {
      var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);
      return execQueue ? execQueue.isRunning : false;
    }
    __name(isRunning, "isRunning");
    exports.isRunning = isRunning;
    function getPrComplete(runExclusiveFunction, classInstanceObject) {
      var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);
      return execQueue ? execQueue.prComplete : Promise.resolve();
    }
    __name(getPrComplete, "getPrComplete");
    exports.getPrComplete = getPrComplete;
    var groupByRunExclusiveFunction = new WeakMap_1.Polyfill();
    function getExecQueueByFunctionAndContext(runExclusiveFunction, context) {
      if (context === void 0) {
        context = globalContext;
      }
      var groupRef = groupByRunExclusiveFunction.get(runExclusiveFunction);
      if (!groupRef) {
        throw Error("Not a run exclusiveFunction");
      }
      var execQueueByGroup = clusters.get(context);
      if (!execQueueByGroup) {
        return void 0;
      }
      return execQueueByGroup.get(groupRef);
    }
    __name(getExecQueueByFunctionAndContext, "getExecQueueByFunctionAndContext");
    function buildFnPromise(isGlobal, groupRef, fun) {
      var execQueue;
      var runExclusiveFunction = /* @__PURE__ */ __name(function() {
        var _this = this;
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          inputs[_i] = arguments[_i];
        }
        if (!isGlobal) {
          if (!(this instanceof Object)) {
            throw new Error("Run exclusive, <this> should be an object");
          }
          execQueue = getOrCreateExecQueue(this, groupRef);
        }
        return new Promise(function(resolve, reject) {
          var onPrCompleteResolve;
          execQueue.prComplete = new Promise(function(resolve2) {
            return onPrCompleteResolve = /* @__PURE__ */ __name(function() {
              return resolve2();
            }, "onPrCompleteResolve");
          });
          var onComplete = /* @__PURE__ */ __name(function(result) {
            onPrCompleteResolve();
            execQueue.isRunning = false;
            if (execQueue.queuedCalls.length) {
              execQueue.queuedCalls.shift()();
            }
            if ("data" in result) {
              resolve(result.data);
            } else {
              reject(result.reason);
            }
          }, "onComplete");
          (/* @__PURE__ */ __name(function callee() {
            var _this2 = this;
            var inputs2 = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              inputs2[_i2] = arguments[_i2];
            }
            if (execQueue.isRunning) {
              execQueue.queuedCalls.push(function() {
                return callee.apply(_this2, inputs2);
              });
              return;
            }
            execQueue.isRunning = true;
            try {
              fun.apply(this, inputs2).then(function(data) {
                return onComplete({ data });
              })["catch"](function(reason) {
                return onComplete({ reason });
              });
            } catch (error) {
              onComplete({ "reason": error });
            }
          }, "callee")).apply(_this, inputs);
        });
      }, "runExclusiveFunction");
      if (isGlobal) {
        execQueue = getOrCreateExecQueue(globalContext, groupRef);
      }
      groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);
      return runExclusiveFunction;
    }
    __name(buildFnPromise, "buildFnPromise");
    function buildCb() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      switch (inputs.length) {
        case 1:
          return buildFnCallback(true, createGroupRef(), inputs[0]);
        case 2:
          return buildFnCallback(true, inputs[0], inputs[1]);
      }
    }
    __name(buildCb, "buildCb");
    exports.buildCb = buildCb;
    function buildMethodCb() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      switch (inputs.length) {
        case 1:
          return buildFnCallback(false, createGroupRef(), inputs[0]);
        case 2:
          return buildFnCallback(false, inputs[0], inputs[1]);
      }
    }
    __name(buildMethodCb, "buildMethodCb");
    exports.buildMethodCb = buildMethodCb;
    function buildFnCallback(isGlobal, groupRef, fun) {
      var execQueue;
      var runExclusiveFunction = /* @__PURE__ */ __name(function() {
        var _this = this;
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          inputs[_i] = arguments[_i];
        }
        if (!isGlobal) {
          if (!(this instanceof Object)) {
            throw new Error("Run exclusive, <this> should be an object");
          }
          execQueue = getOrCreateExecQueue(this, groupRef);
        }
        var callback = void 0;
        if (inputs.length && typeof inputs[inputs.length - 1] === "function") {
          callback = inputs.pop();
        }
        var onPrCompleteResolve;
        execQueue.prComplete = new Promise(function(resolve) {
          return onPrCompleteResolve = /* @__PURE__ */ __name(function() {
            return resolve();
          }, "onPrCompleteResolve");
        });
        var onComplete = /* @__PURE__ */ __name(function() {
          var inputs2 = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            inputs2[_i2] = arguments[_i2];
          }
          onPrCompleteResolve();
          execQueue.isRunning = false;
          if (execQueue.queuedCalls.length) {
            execQueue.queuedCalls.shift()();
          }
          if (callback) {
            callback.apply(_this, inputs2);
          }
        }, "onComplete");
        onComplete.hasCallback = !!callback;
        (/* @__PURE__ */ __name(function callee() {
          var _this2 = this;
          var inputs2 = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            inputs2[_i2] = arguments[_i2];
          }
          if (execQueue.isRunning) {
            execQueue.queuedCalls.push(function() {
              return callee.apply(_this2, inputs2);
            });
            return;
          }
          execQueue.isRunning = true;
          try {
            fun.apply(this, __spreadArrays(inputs2, [onComplete]));
          } catch (error) {
            error.message += " ( This exception should not have been thrown, miss use of run-exclusive buildCb )";
            throw error;
          }
        }, "callee")).apply(this, inputs);
      }, "runExclusiveFunction");
      if (isGlobal) {
        execQueue = getOrCreateExecQueue(globalContext, groupRef);
      }
      groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);
      return runExclusiveFunction;
    }
    __name(buildFnCallback, "buildFnCallback");
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/tools/Deferred.js
var require_Deferred = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/tools/Deferred.js"(exports) {
    "use strict";
    init_esm();
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d3[p] = b3[p];
        };
        return extendStatics(d2, b2);
      }, "extendStatics");
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        __name(__, "__");
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoidDeferred = exports.Deferred = void 0;
    var overwriteReadonlyProp_1 = require_overwriteReadonlyProp();
    var Deferred = (
      /** @class */
      /* @__PURE__ */ function() {
        function Deferred2() {
          var _this_1 = this;
          this.isPending = true;
          var resolve;
          var reject;
          this.pr = new Promise(function(resolve_, reject_) {
            resolve = /* @__PURE__ */ __name(function(value) {
              (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(_this_1, "isPending", false);
              resolve_(value);
            }, "resolve");
            reject = /* @__PURE__ */ __name(function(error) {
              (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(_this_1, "isPending", false);
              reject_(error);
            }, "reject");
          });
          this.resolve = resolve;
          this.reject = reject;
        }
        __name(Deferred2, "Deferred");
        return Deferred2;
      }()
    );
    exports.Deferred = Deferred;
    var VoidDeferred = (
      /** @class */
      function(_super) {
        __extends(VoidDeferred2, _super);
        function VoidDeferred2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        __name(VoidDeferred2, "VoidDeferred");
        return VoidDeferred2;
      }(Deferred)
    );
    exports.VoidDeferred = VoidDeferred;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.loosenType.js
var require_Evt_loosenType = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.loosenType.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loosenType = void 0;
    function loosenType(evt) {
      return evt;
    }
    __name(loosenType, "loosenType");
    exports.loosenType = loosenType;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/tools/safeSetTimeout.js
var require_safeSetTimeout = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/tools/safeSetTimeout.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeClearTimeout = exports.safeSetTimeout = void 0;
    var safeSetTimeout = /* @__PURE__ */ __name(function(callback, ms) {
      return setTimeout(callback, ms);
    }, "safeSetTimeout");
    exports.safeSetTimeout = safeSetTimeout;
    var safeClearTimeout = /* @__PURE__ */ __name(function(timer) {
      return clearTimeout(timer);
    }, "safeClearTimeout");
    exports.safeClearTimeout = safeClearTimeout;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/isPromiseLike.js
var require_isPromiseLike = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/tsafe/isPromiseLike.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromiseLike = isPromiseLike;
    function isPromiseLike(o3) {
      return typeof o3 === "object" && o3 !== null && "then" in o3 && typeof o3.then === "function";
    }
    __name(isPromiseLike, "isPromiseLike");
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.js
var require_Evt = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/Evt.js"(exports) {
    "use strict";
    init_esm();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k2];
        }, "get") };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o3[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v });
    } : function(o3, v) {
      o3["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _3 = { label: 0, sent: /* @__PURE__ */ __name(function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, "sent"), trys: [], ops: [] }, f, y2, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_3) try {
          if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) return t;
          if (y2 = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _3.label++;
              return { value: op[1], done: false };
            case 5:
              _3.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _3.ops.pop();
              _3.trys.pop();
              continue;
            default:
              if (!(t = _3.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _3 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _3.label = op[1];
                break;
              }
              if (op[0] === 6 && _3.label < t[1]) {
                _3.label = t[1];
                t = op;
                break;
              }
              if (t && _3.label < t[2]) {
                _3.label = t[2];
                _3.ops.push(op);
                break;
              }
              if (t[2]) _3.ops.pop();
              _3.trys.pop();
              continue;
          }
          op = body.call(thisArg, _3);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __read = exports && exports.__read || function(o3, n) {
      var m = typeof Symbol === "function" && o3[Symbol.iterator];
      if (!m) return o3;
      var i = m.call(o3), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m = i["return"])) m.call(i);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __values = exports && exports.__values || function(o3) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o3[s], i = 0;
      if (m) return m.call(o3);
      if (o3 && typeof o3.length === "number") return {
        next: /* @__PURE__ */ __name(function() {
          if (o3 && i >= o3.length) o3 = void 0;
          return { value: o3 && o3[i++], done: !o3 };
        }, "next")
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Evt = exports.onAddHandlerByEvt = void 0;
    require_Array_prototype_find();
    var Map_1 = require_Map();
    var WeakMap_1 = require_WeakMap();
    var importProxy_1 = require_importProxy();
    var Evt_create_1 = require_Evt_create();
    var Evt_getCtx_1 = require_Evt_getCtx();
    var Evt_factorize_1 = require_Evt_factorize();
    var Evt_merge_1 = require_Evt_merge();
    var Evt_from_1 = require_Evt_from();
    var Evt_asPostable_1 = require_Evt_asPostable();
    var Evt_asyncPipe_1 = require_Evt_asyncPipe();
    var Evt_asNonPostable_1 = require_Evt_asNonPostable();
    var Evt_parsePropsFromArgs_1 = require_Evt_parsePropsFromArgs();
    var Evt_newCtx_1 = require_Evt_newCtx();
    var LazyEvt_1 = require_LazyEvt();
    var runExclusive = __importStar(require_runExclusive());
    var overwriteReadonlyProp_1 = require_overwriteReadonlyProp();
    var typeGuard_1 = require_typeGuard();
    var Deferred_1 = require_Deferred();
    var Evt_loosenType_1 = require_Evt_loosenType();
    var safeSetTimeout_1 = require_safeSetTimeout();
    var isPromiseLike_1 = require_isPromiseLike();
    var EvtError_1 = require_EvtError();
    var nsCtxLike = __importStar(require_CtxLike());
    var convertOperatorToStatelessFLambda_1 = require_convertOperatorToStatelessFLambda();
    var runSideEffect = /* @__PURE__ */ __name(function(sideEffect) {
      return sideEffect();
    }, "runSideEffect");
    var CtxLikeAsValue = nsCtxLike.CtxLike;
    var EvtImpl = (
      /** @class */
      function() {
        function EvtImpl2() {
          this.lazyEvtAttach = new LazyEvt_1.LazyEvt();
          this.lazyEvtDetach = new LazyEvt_1.LazyEvt();
          this.__maxHandlers = void 0;
          this.postCount = 0;
          this.traceId = null;
          this.handlers = [];
          this.handlerTriggers = new Map_1.Polyfill();
          this.__currentChronologyMark = 0;
          this.asyncHandlerCount = 0;
        }
        __name(EvtImpl2, "EvtImpl");
        EvtImpl2.setDefaultMaxHandlers = function(n) {
          this.__defaultMaxHandlers = isFinite(n) ? n : 0;
        };
        EvtImpl2.prototype.toStateful = function(p1, p2) {
          var isP1Ctx = CtxLikeAsValue.match(p1);
          var initialValue = isP1Ctx ? void 0 : p1;
          var ctx = p2 || (isP1Ctx ? p1 : void 0);
          var out = new importProxy_1.importProxy.StatefulEvt(initialValue);
          var callback = /* @__PURE__ */ __name(function(data) {
            return out.post(data);
          }, "callback");
          if (!!ctx) {
            this.attach(ctx, callback);
          } else {
            this.attach(callback);
          }
          return out;
        };
        Object.defineProperty(EvtImpl2.prototype, "evtAttach", {
          get: /* @__PURE__ */ __name(function() {
            return this.lazyEvtAttach.evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(EvtImpl2.prototype, "evtDetach", {
          get: /* @__PURE__ */ __name(function() {
            return this.lazyEvtDetach.evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        EvtImpl2.prototype.setMaxHandlers = function(n) {
          this.__maxHandlers = isFinite(n) ? n : 0;
          return this;
        };
        EvtImpl2.prototype.enableTrace = function(params) {
          var id = params.id, formatter = params.formatter, log = params.log;
          this.traceId = id;
          this.traceFormatter = formatter || function(data) {
            try {
              return JSON.stringify(data, null, 2);
            } catch (_a) {
              return "".concat(data);
            }
          };
          this.log = log === void 0 ? function() {
            var inputs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              inputs[_i] = arguments[_i];
            }
            return console.log.apply(console, __spreadArray([], __read(inputs), false));
          } : log === false ? void 0 : log;
        };
        EvtImpl2.prototype.disableTrace = function() {
          this.traceId = null;
          return this;
        };
        Object.defineProperty(EvtImpl2.prototype, "asyncHandlerChronologyMark", {
          //NOTE: An async handler ( attached with waitFor ) is only eligible to handle a post if the post
          //occurred after the handler was set. We don't want to waitFor event from the past.
          //private readonly asyncHandlerChronologyMark = new WeakMap<ImplicitParams.Async, number>();
          get: /* @__PURE__ */ __name(function() {
            var _a, _b;
            var _c, _d;
            return (_b = (_d = (_a = (_c = this)["~internal"]) !== null && _a !== void 0 ? _a : _c["~internal"] = {})["asyncHandlerChronologyMark"]) !== null && _b !== void 0 ? _b : _d["asyncHandlerChronologyMark"] = new WeakMap_1.Polyfill();
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(EvtImpl2.prototype, "asyncHandlerChronologyExceptionRange", {
          //NOTE: There is an exception to the above rule, we want to allow async waitFor loop 
          //do so we have to handle the case where multiple event would be posted synchronously.
          get: /* @__PURE__ */ __name(function() {
            var _a, _b;
            var _c, _d;
            return (_b = (_d = (_a = (_c = this)["~internal"]) !== null && _a !== void 0 ? _a : _c["~internal"] = {})["asyncHandlerChronologyExceptionRange"]) !== null && _b !== void 0 ? _b : _d["asyncHandlerChronologyExceptionRange"] = new WeakMap_1.Polyfill();
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(EvtImpl2.prototype, "invocableOpByOp", {
          get: /* @__PURE__ */ __name(function() {
            var _a, _b;
            var _c, _d;
            return (_b = (_d = (_a = (_c = this)["~internal"]) !== null && _a !== void 0 ? _a : _c["~internal"] = {})["invocableOpByOp"]) !== null && _b !== void 0 ? _b : _d["invocableOpByOp"] = new WeakMap_1.Polyfill();
          }, "get"),
          enumerable: false,
          configurable: true
        });
        EvtImpl2.prototype.getInvocableOp = function(op) {
          var invocableOp = this.invocableOpByOp.get(op);
          if (invocableOp === void 0) {
            throw new Error([
              "Provided operator isn't the operator of any handler",
              "currently attached to the Evt instance"
            ].join(" "));
          }
          return invocableOp;
        };
        EvtImpl2.prototype.getChronologyMark = function() {
          return this.__currentChronologyMark++;
        };
        EvtImpl2.prototype.detachHandler = function(handler, wTimer, rejectPr) {
          var index = this.handlers.indexOf(handler);
          if (index < 0) {
            return false;
          }
          if ((0, typeGuard_1.typeGuard)(handler, !!handler.ctx)) {
            handler.ctx.zz__removeHandler(handler);
          }
          this.handlers.splice(index, 1);
          if (handler.async) {
            this.asyncHandlerCount--;
          }
          this.handlerTriggers.delete(handler);
          if (wTimer[0] !== void 0) {
            (0, safeSetTimeout_1.safeClearTimeout)(wTimer[0]);
            rejectPr(new EvtError_1.DetachedEvtError());
          }
          this.lazyEvtDetach.post(handler);
          return true;
        };
        EvtImpl2.prototype.triggerHandler = function(handler, wTimer, resolvePr, opResult) {
          var callback = handler.callback, once = handler.once;
          if (wTimer[0] !== void 0) {
            (0, safeSetTimeout_1.safeClearTimeout)(wTimer[0]);
            wTimer[0] = void 0;
          }
          if (once) {
            handler.detach();
          }
          var _a = __read(opResult, 1), transformedData = _a[0];
          var prOrValue = callback === null || callback === void 0 ? void 0 : callback.call(this, transformedData);
          resolvePr === null || resolvePr === void 0 ? void 0 : resolvePr(transformedData);
          return (0, isPromiseLike_1.isPromiseLike)(prOrValue) ? prOrValue : void 0;
        };
        EvtImpl2.prototype.addHandler = function(propsFromArgs, propsFromMethodName) {
          var _this_1 = this;
          var _a;
          this.invocableOpByOp.set(propsFromArgs.op, (0, convertOperatorToStatelessFLambda_1.convertOperatorToStatelessFλ)(propsFromArgs.op));
          var d2 = new Deferred_1.Deferred();
          var wTimer = [void 0];
          var handler = __assign(__assign(__assign({}, propsFromArgs), propsFromMethodName), { "detach": /* @__PURE__ */ __name(function() {
            return _this_1.detachHandler(handler, wTimer, d2.reject);
          }, "detach"), "promise": d2.pr });
          if (typeof handler.timeout === "number") {
            wTimer[0] = (0, safeSetTimeout_1.safeSetTimeout)(function() {
              wTimer[0] = void 0;
              handler.detach();
              d2.reject(new EvtError_1.TimeoutEvtError(handler.timeout));
            }, handler.timeout);
          }
          var handlerTrigger = /* @__PURE__ */ __name(function(opResult) {
            return _this_1.triggerHandler(handler, wTimer, d2.isPending ? d2.resolve : void 0, opResult);
          }, "handlerTrigger");
          this.handlerTriggers.set(handler, handlerTrigger);
          if (handler.async) {
            this.asyncHandlerChronologyMark.set(handler, this.getChronologyMark());
          }
          if (handler.prepend) {
            var i = void 0;
            for (i = 0; i < this.handlers.length; i++) {
              if (this.handlers[i].extract) {
                continue;
              }
              break;
            }
            this.handlers.splice(i, 0, handler);
          } else {
            this.handlers.push(handler);
          }
          if (handler.async) {
            this.asyncHandlerCount++;
          }
          this.checkForPotentialMemoryLeak();
          if ((0, typeGuard_1.typeGuard)(handler, !!handler.ctx)) {
            handler.ctx.zz__addHandler(handler, this);
          }
          (_a = exports.onAddHandlerByEvt.get(this)) === null || _a === void 0 ? void 0 : _a(handler, handlerTrigger);
          if (this.handlerTriggers.has(handler)) {
            this.lazyEvtAttach.post(handler);
          }
          return handler;
        };
        EvtImpl2.prototype.checkForPotentialMemoryLeak = function() {
          var maxHandlers = this.__maxHandlers !== void 0 ? this.__maxHandlers : EvtImpl2.__defaultMaxHandlers;
          if (maxHandlers === 0 || this.handlers.length % (maxHandlers + 1) !== 0) {
            return;
          }
          var message = [
            "MaxHandlersExceededWarning: Possible Evt memory leak detected.",
            "".concat(this.handlers.length, " handlers attached").concat(this.traceId ? ' to "'.concat(this.traceId, '"') : "", ".\n"),
            "Use Evt.prototype.setMaxHandlers(n) to increase limit on a specific Evt.\n",
            "Use Evt.setDefaultMaxHandlers(n) to change the default limit currently set to ".concat(EvtImpl2.__defaultMaxHandlers, ".\n")
          ].join("");
          var map = new Map_1.Polyfill();
          this.getHandlers().map(function(_a) {
            var ctx = _a.ctx, async = _a.async, once = _a.once, prepend = _a.prepend, extract = _a.extract, op = _a.op, callback = _a.callback;
            return __assign(__assign({ "hasCtx": !!ctx, once, prepend, extract, "isWaitFor": async }, op === Evt_parsePropsFromArgs_1.matchAll ? {} : { "op": op.toString() }), !callback ? {} : { "callback": callback.toString() });
          }).map(function(obj) {
            return "{\n" + Object.keys(obj).map(function(key) {
              return "  ".concat(key, ": ").concat(obj[key]);
            }).join(",\n") + "\n}";
          }).forEach(function(str) {
            return map.set(str, (map.has(str) ? map.get(str) : 0) + 1);
          });
          message += "\n" + Array.from(map.keys()).map(function(str) {
            return "".concat(map.get(str), " handler").concat(map.get(str) === 1 ? "" : "s", " like:\n").concat(str);
          }).join("\n") + "\n";
          if (this.traceId === null) {
            message += "\n" + [
              "To validate the identify of the Evt instance that is triggering this warning you can call",
              'Evt.prototype.enableTrace({ "id": "My evt id", "log": false }) on the Evt that you suspect.\n'
            ].join(" ");
          }
          try {
            console.warn(message);
          } catch (_a) {
          }
        };
        EvtImpl2.prototype.isHandledByOp = function(op, data) {
          var hasSideEffect = false;
          var invocableOp;
          try {
            invocableOp = this.getInvocableOp(op);
          } catch (_a) {
            return false;
          }
          var opResult = invocableOp(data, function() {
            return hasSideEffect = true;
          });
          return opResult !== null || hasSideEffect;
        };
        EvtImpl2.prototype.trace = function(data) {
          var _this_1 = this;
          var _a;
          if (this.traceId === null) {
            return;
          }
          var message = "(".concat(this.traceId, ") ");
          var isExtracted = !!this.handlers.find(function(_a2) {
            var extract = _a2.extract, op = _a2.op;
            return extract && _this_1.isHandledByOp(op, data);
          });
          if (isExtracted) {
            message += "extracted ";
          } else {
            var handlerCount = this.handlers.filter(function(_a2) {
              var extract = _a2.extract, op = _a2.op;
              return !extract && _this_1.isHandledByOp(op, data);
            }).length;
            message += "".concat(handlerCount, " handler").concat(handlerCount > 1 ? "s" : "", ", ");
          }
          (_a = this.log) === null || _a === void 0 ? void 0 : _a.call(this, message + this.traceFormatter(data));
        };
        EvtImpl2.prototype.postSync = function(data) {
          var e_1, _a;
          var prAllHandlerCallbacksResolved = [];
          var getReturnValue = /* @__PURE__ */ __name(function(isExtracted) {
            return [
              isExtracted,
              Promise.all(prAllHandlerCallbacksResolved).then(function() {
              })
            ];
          }, "getReturnValue");
          try {
            for (var _b = __values(__spreadArray([], __read(this.handlers), false)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var handler = _c.value;
              var async = handler.async, op = handler.op, extract = handler.extract;
              if (async) {
                continue;
              }
              var handlerTrigger = this.handlerTriggers.get(handler);
              var opResult = this.getInvocableOp(op)(data, runSideEffect);
              if (opResult === null) {
                continue;
              }
              if (!handlerTrigger) {
                continue;
              }
              var prOrUndefined = handlerTrigger(opResult);
              if (prOrUndefined !== void 0) {
                prAllHandlerCallbacksResolved.push(prOrUndefined);
              }
              if (extract) {
                return getReturnValue(true);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return getReturnValue(false);
        };
        EvtImpl2.prototype.postAsyncFactory = function() {
          var _this_1 = this;
          return runExclusive.buildMethodCb(function(data, postChronologyMark, releaseLock) {
            var e_2, _a;
            if (_this_1.asyncHandlerCount === 0) {
              releaseLock();
              return;
            }
            var promises = [];
            var chronologyMarkStartResolveTick;
            Promise.resolve().then(function() {
              return chronologyMarkStartResolveTick = _this_1.getChronologyMark();
            });
            var _loop_1 = /* @__PURE__ */ __name(function(handler2) {
              if (!handler2.async) {
                return "continue";
              }
              var opResult = _this_1.getInvocableOp(handler2.op)(data, runSideEffect);
              if (opResult === null) {
                return "continue";
              }
              var handlerTrigger = _this_1.handlerTriggers.get(handler2);
              if (!handlerTrigger) {
                return "continue";
              }
              var shouldCallHandlerTrigger = function() {
                var handlerMark = _this_1.asyncHandlerChronologyMark.get(handler2);
                if (postChronologyMark > handlerMark) {
                  return true;
                }
                var exceptionRange = _this_1.asyncHandlerChronologyExceptionRange.get(handler2);
                return exceptionRange !== void 0 && exceptionRange.lowerMark < postChronologyMark && postChronologyMark < exceptionRange.upperMark && handlerMark > exceptionRange.upperMark;
              }();
              if (!shouldCallHandlerTrigger) {
                return "continue";
              }
              promises.push(new Promise(function(resolve) {
                return handler2.promise.then(function() {
                  return resolve();
                }).catch(function() {
                  return resolve();
                });
              }));
              handlerTrigger(opResult);
            }, "_loop_1");
            try {
              for (var _b = __values(__spreadArray([], __read(_this_1.handlers), false)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var handler = _c.value;
                _loop_1(handler);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              } finally {
                if (e_2) throw e_2.error;
              }
            }
            if (promises.length === 0) {
              releaseLock();
              return;
            }
            var handlersDump = __spreadArray([], __read(_this_1.handlers), false);
            Promise.all(promises).then(function() {
              var e_3, _a2;
              try {
                for (var _b2 = __values(_this_1.handlers), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                  var handler2 = _c2.value;
                  if (!handler2.async) {
                    continue;
                  }
                  if (handlersDump.indexOf(handler2) >= 0) {
                    continue;
                  }
                  _this_1.asyncHandlerChronologyExceptionRange.set(handler2, {
                    "lowerMark": postChronologyMark,
                    "upperMark": chronologyMarkStartResolveTick
                  });
                }
              } catch (e_3_1) {
                e_3 = { error: e_3_1 };
              } finally {
                try {
                  if (_c2 && !_c2.done && (_a2 = _b2.return)) _a2.call(_b2);
                } finally {
                  if (e_3) throw e_3.error;
                }
              }
              releaseLock();
            });
          });
        };
        EvtImpl2.prototype.isHandled = function(data) {
          var _this_1 = this;
          return !!this.getHandlers().find(function(_a) {
            var op = _a.op;
            return _this_1.isHandledByOp(op, data);
          });
        };
        EvtImpl2.prototype.getHandlers = function() {
          return __spreadArray([], __read(this.handlers), false);
        };
        EvtImpl2.prototype.detach = function(ctx) {
          var e_4, _a;
          var detachedHandlers = [];
          try {
            for (var _b = __values(this.getHandlers()), _c = _b.next(); !_c.done; _c = _b.next()) {
              var handler = _c.value;
              if (ctx !== void 0 && handler.ctx !== ctx) {
                continue;
              }
              var wasStillAttached = handler.detach();
              if (!wasStillAttached) {
                continue;
              }
              detachedHandlers.push(handler);
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_4) throw e_4.error;
            }
          }
          return detachedHandlers;
        };
        EvtImpl2.prototype.pipe = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var evtDelegate = new EvtImpl2();
          this.addHandler(__assign(__assign({}, (0, Evt_parsePropsFromArgs_1.parsePropsFromArgs)(args, "pipe")), { "callback": /* @__PURE__ */ __name(function(transformedData) {
            return evtDelegate.post(transformedData);
          }, "callback") }), EvtImpl2.propsFormMethodNames.attach);
          return evtDelegate;
        };
        EvtImpl2.prototype.waitFor = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.addHandler((0, Evt_parsePropsFromArgs_1.parsePropsFromArgs)(args, "waitFor"), EvtImpl2.propsFormMethodNames.waitFor).promise;
        };
        EvtImpl2.prototype[Symbol.asyncIterator] = function() {
          return this.iter()[Symbol.asyncIterator]();
        };
        EvtImpl2.prototype.iter = function() {
          var _a;
          var _b;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var props = (0, Evt_parsePropsFromArgs_1.parsePropsFromArgs)(args, "waitFor");
          var ctx = (_b = props.ctx) !== null && _b !== void 0 ? _b : (0, Evt_newCtx_1.newCtx)();
          var self = this;
          return _a = {
            ctx
          }, _a[Symbol.asyncIterator] = function() {
            var previousDonePostCount = ctx.evtDoneOrAborted.postCount;
            var timerWrap = function() {
              var timeout = props.timeout;
              if (timeout === void 0) {
                return void 0;
              }
              var setTimeoutCallback = /* @__PURE__ */ __name(function() {
                var error = new EvtError_1.TimeoutEvtError(timeout);
                ctx.abort(error);
              }, "setTimeoutCallback");
              var timer = setTimeout(setTimeoutCallback, timeout);
              return { timeout, setTimeoutCallback, timer };
            }();
            var evtProxy = self.pipe(ctx, props.op).pipe(function(data, registerSideEffect) {
              if (timerWrap !== void 0) {
                registerSideEffect(function() {
                  clearTimeout(timerWrap.timer);
                  timerWrap.timer = setTimeout(timerWrap.setTimeoutCallback, timerWrap.timeout);
                });
              }
              return [data];
            });
            var events = [];
            evtProxy.attach(function(event) {
              return events.push([event]);
            });
            if (timerWrap !== void 0) {
              var timer_1 = timerWrap.timer;
              ctx.evtDoneOrAborted.attachOnce(function(event) {
                return event.type === "DONE";
              }, function() {
                return clearTimeout(timer_1);
              });
            }
            return {
              next: /* @__PURE__ */ __name(function() {
                return __awaiter(this, void 0, void 0, function() {
                  var eventWrap, dEventWrap_1, ctx2_1, out;
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        eventWrap = events.shift();
                        if (!(eventWrap === void 0)) return [3, 2];
                        dEventWrap_1 = new Deferred_1.Deferred();
                        if (previousDonePostCount < ctx.evtDoneOrAborted.postCount) {
                          return [2, { "done": true }];
                        }
                        ctx2_1 = (0, Evt_newCtx_1.newCtx)();
                        ctx.evtDoneOrAborted.attachOnce(ctx2_1, function() {
                          return dEventWrap_1.resolve(void 0);
                        });
                        evtProxy.attachOnceExtract(ctx2_1, function(event) {
                          ctx2_1.done();
                          dEventWrap_1.resolve([event]);
                        });
                        return [4, dEventWrap_1.pr];
                      case 1:
                        eventWrap = _a2.sent();
                        if (eventWrap === void 0) {
                          return [2, { "done": true }];
                        }
                        _a2.label = 2;
                      case 2:
                        out = { "done": false, "value": eventWrap[0] };
                        return [2, out];
                    }
                  });
                });
              }, "next"),
              return: /* @__PURE__ */ __name(function() {
                self.detach(ctx);
                return { "done": true };
              }, "return"),
              throw: /* @__PURE__ */ __name(function(error) {
                self.detach(ctx);
                return Promise.reject(error);
              }, "throw")
            };
          }, _a;
        };
        EvtImpl2.prototype.$attach = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.attach.apply(this, __spreadArray([], __read(args), false));
        };
        EvtImpl2.prototype.attach = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.__attachX(args, "attach");
        };
        EvtImpl2.prototype.$attachOnce = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.attachOnce.apply(this, __spreadArray([], __read(args), false));
        };
        EvtImpl2.prototype.attachOnce = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.__attachX(args, "attachOnce");
        };
        EvtImpl2.prototype.$attachExtract = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.attachExtract.apply(this, __spreadArray([], __read(args), false));
        };
        EvtImpl2.prototype.attachExtract = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.__attachX(args, "attachExtract");
        };
        EvtImpl2.prototype.$attachPrepend = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.attachPrepend.apply(this, __spreadArray([], __read(args), false));
        };
        EvtImpl2.prototype.attachPrepend = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.__attachX(args, "attachPrepend");
        };
        EvtImpl2.prototype.$attachOncePrepend = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.attachOncePrepend.apply(this, __spreadArray([], __read(args), false));
        };
        EvtImpl2.prototype.attachOncePrepend = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.__attachX(args, "attachOncePrepend");
        };
        EvtImpl2.prototype.$attachOnceExtract = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.attachOnceExtract.apply(this, __spreadArray([], __read(args), false));
        };
        EvtImpl2.prototype.attachOnceExtract = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return this.__attachX(args, "attachOnceExtract");
        };
        EvtImpl2.prototype.__attachX = function(args, methodName) {
          var propsFromArgs = (0, Evt_parsePropsFromArgs_1.parsePropsFromArgs)(args, "attach*");
          var handler = this.addHandler(propsFromArgs, EvtImpl2.propsFormMethodNames[methodName]);
          return propsFromArgs.timeout === void 0 ? this : handler.promise;
        };
        EvtImpl2.prototype.postAsyncOnceHandled = function(data) {
          var _this_1 = this;
          if (this.isHandled(data)) {
            return this.post(data);
          }
          var d2 = new Deferred_1.Deferred();
          this.evtAttach.attachOnce(function(_a) {
            var op = _a.op;
            return _this_1.isHandledByOp(op, data);
          }, function() {
            return Promise.resolve().then(function() {
              return d2.resolve(_this_1.post(data));
            });
          });
          return d2.pr;
        };
        EvtImpl2.prototype.postOrPostAndWait = function(data, wait) {
          var _this_1 = this;
          this.trace(data);
          (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(this, "postCount", this.postCount + 1);
          var postChronologyMark = this.getChronologyMark();
          var _a = __read(this.postSync(data), 2), isExtracted = _a[0], prAllHandlerCallbacksResolved = _a[1];
          var getReturnValue = wait ? function() {
            return prAllHandlerCallbacksResolved;
          } : function() {
            return _this_1.postCount;
          };
          if (isExtracted) {
            return getReturnValue();
          }
          if (this.postAsync === void 0) {
            if (this.asyncHandlerCount === 0) {
              return getReturnValue();
            }
            this.postAsync = this.postAsyncFactory();
          }
          this.postAsync(data, postChronologyMark);
          return getReturnValue();
        };
        EvtImpl2.prototype.post = function(data) {
          return this.postOrPostAndWait(data, false);
        };
        EvtImpl2.prototype.postAndWait = function(data) {
          return this.postOrPostAndWait(data, true);
        };
        EvtImpl2.create = Evt_create_1.create;
        EvtImpl2.newCtx = Evt_newCtx_1.newCtx;
        EvtImpl2.merge = Evt_merge_1.merge;
        EvtImpl2.from = Evt_from_1.from;
        EvtImpl2.getCtx = (0, Evt_getCtx_1.getCtxFactory)();
        EvtImpl2.loosenType = Evt_loosenType_1.loosenType;
        EvtImpl2.factorize = Evt_factorize_1.factorize;
        EvtImpl2.asPostable = Evt_asPostable_1.asPostable;
        EvtImpl2.asyncPipe = Evt_asyncPipe_1.asyncPipe;
        EvtImpl2.asNonPostable = Evt_asNonPostable_1.asNonPostable;
        EvtImpl2.__defaultMaxHandlers = 25;
        EvtImpl2.propsFormMethodNames = {
          "waitFor": { "async": true, "extract": false, "once": true, "prepend": false },
          "attach": { "async": false, "extract": false, "once": false, "prepend": false },
          "attachExtract": { "async": false, "extract": true, "once": false, "prepend": true },
          "attachPrepend": { "async": false, "extract": false, "once": false, "prepend": true },
          "attachOnce": { "async": false, "extract": false, "once": true, "prepend": false },
          "attachOncePrepend": { "async": false, "extract": false, "once": true, "prepend": true },
          "attachOnceExtract": { "async": false, "extract": true, "once": true, "prepend": true }
        };
        return EvtImpl2;
      }()
    );
    exports.onAddHandlerByEvt = new WeakMap_1.Polyfill();
    exports.Evt = EvtImpl;
    try {
      (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(exports.Evt, "name", "Evt");
    } catch (_a) {
    }
    importProxy_1.importProxy.Evt = exports.Evt;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/Object.is.js
var require_Object_is = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/minimal-polyfills/Object.is.js"(exports) {
    "use strict";
    init_esm();
    exports.__esModule = true;
    if (!Object.is) {
      Object.is = function(x, y2) {
        if (x === y2) {
          return x !== 0 || 1 / x === 1 / y2;
        } else {
          return x !== x && y2 !== y2;
        }
      };
    }
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/LazyStatefulEvt.js
var require_LazyStatefulEvt = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/LazyStatefulEvt.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LazyStatefulEvt = void 0;
    var overwriteReadonlyProp_1 = require_overwriteReadonlyProp();
    var importProxy_1 = require_importProxy();
    var LazyStatefulEvt = (
      /** @class */
      function() {
        function LazyStatefulEvt2(initialState) {
          this.initialPostCount = 0;
          this.initialState = initialState;
        }
        __name(LazyStatefulEvt2, "LazyStatefulEvt");
        Object.defineProperty(LazyStatefulEvt2.prototype, "evt", {
          get: /* @__PURE__ */ __name(function() {
            if (this.__evt === void 0) {
              this.__evt = new importProxy_1.importProxy.StatefulEvt(this.initialState);
              this.initialState = null;
              (0, overwriteReadonlyProp_1.overwriteReadonlyProp)(this.__evt, "postCount", this.initialPostCount);
            }
            return this.__evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        LazyStatefulEvt2.prototype.__post = function(data, doWait) {
          if (this.__evt === void 0) {
            this.initialState = data;
            return ++this.initialPostCount;
          }
          return this.__evt[doWait ? "postAndWait" : "post"](data);
        };
        LazyStatefulEvt2.prototype.post = function(data) {
          return this.__post(data, false);
        };
        LazyStatefulEvt2.prototype.postAndWait = function(data) {
          return this.__post(data, true);
        };
        return LazyStatefulEvt2;
      }()
    );
    exports.LazyStatefulEvt = LazyStatefulEvt;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/StatefulEvt.js
var require_StatefulEvt = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/StatefulEvt.js"(exports) {
    "use strict";
    init_esm();
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d3[p] = b3[p];
        };
        return extendStatics(d2, b2);
      }, "extendStatics");
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        __name(__, "__");
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __read = exports && exports.__read || function(o3, n) {
      var m = typeof Symbol === "function" && o3[Symbol.iterator];
      if (!m) return o3;
      var i = m.call(o3), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m = i["return"])) m.call(i);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatefulEvt = void 0;
    require_Object_is();
    var LazyEvt_1 = require_LazyEvt();
    var LazyStatefulEvt_1 = require_LazyStatefulEvt();
    var importProxy_1 = require_importProxy();
    var Evt_2 = require_Evt();
    var assert_1 = require_assert();
    var id_1 = require_id();
    var runSideEffect = /* @__PURE__ */ __name(function(sideEffect) {
      return sideEffect();
    }, "runSideEffect");
    var StatefulEvtImpl = (
      /** @class */
      function(_super) {
        __extends(StatefulEvtImpl2, _super);
        function StatefulEvtImpl2(initialState) {
          var _this_1 = _super.call(this) || this;
          _this_1.lazyEvtDiff = new LazyEvt_1.LazyEvt();
          _this_1.lazyEvtChangeDiff = new LazyEvt_1.LazyEvt();
          _this_1.__state = initialState;
          _this_1.lazyEvtChange = new LazyStatefulEvt_1.LazyStatefulEvt(_this_1.__state);
          Evt_2.onAddHandlerByEvt.set(_this_1, function(handler, handlerTrigger) {
            if (handler.extract) {
              return;
            }
            var sideEffect = (0, id_1.id)(void 0);
            var opResult = _this_1.getInvocableOp(handler.op)(_this_1.__state, _this_1.setOpResultForPipe !== void 0 ? function(sideEffect_) {
              return sideEffect = sideEffect_;
            } : runSideEffect);
            if (_this_1.setOpResultForPipe !== void 0) {
              _this_1.setOpResultForPipe(opResult);
              if (sideEffect !== void 0) {
                sideEffect();
              }
            }
            if (!opResult) {
              return;
            }
            handlerTrigger(opResult);
          });
          return _this_1;
        }
        __name(StatefulEvtImpl2, "StatefulEvtImpl");
        Object.defineProperty(StatefulEvtImpl2.prototype, "state", {
          get: /* @__PURE__ */ __name(function() {
            return this.__state;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            if (this.state === value)
              return;
            this.post(value);
          }, "set"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(StatefulEvtImpl2.prototype, "evtDiff", {
          get: /* @__PURE__ */ __name(function() {
            return this.lazyEvtDiff.evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(StatefulEvtImpl2.prototype, "evtChange", {
          get: /* @__PURE__ */ __name(function() {
            return this.lazyEvtChange.evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(StatefulEvtImpl2.prototype, "evtChangeDiff", {
          get: /* @__PURE__ */ __name(function() {
            return this.lazyEvtChangeDiff.evt;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        StatefulEvtImpl2.prototype.post = function(data) {
          return this.__post(data, false, false);
        };
        StatefulEvtImpl2.prototype.postForceChange = function(wData) {
          return this.__post(!!wData ? wData[0] : this.state, true, false);
        };
        StatefulEvtImpl2.prototype.postAndWait = function(data) {
          return this.__post(data, false, true);
        };
        StatefulEvtImpl2.prototype.__post = function(data, forceChange, doWait) {
          var prevState = this.state;
          this.__state = data;
          var diff = { prevState, "newState": this.state };
          var postVariantName = doWait ? "postAndWait" : "post";
          var prs = [];
          var r1 = this.lazyEvtDiff[postVariantName](diff);
          if (doWait) {
            prs.push(r1);
          }
          if (forceChange || !Object.is(prevState, this.state)) {
            var r2 = this.lazyEvtChange[postVariantName](this.state);
            var r3 = this.lazyEvtChangeDiff[postVariantName](diff);
            if (doWait) {
              prs.push(r2, r3);
            }
          }
          var r4 = _super.prototype[postVariantName].call(this, data);
          return doWait ? (prs.push(r4), Promise.all(prs).then(function() {
          })) : r4;
        };
        StatefulEvtImpl2.prototype.pipe = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var opResult = void 0;
          this.setOpResultForPipe = function(opResult_) {
            return opResult = opResult_;
          };
          var evt = _super.prototype.pipe.apply(this, __spreadArray([], __read(args), false));
          (0, assert_1.assert)(opResult !== void 0);
          this.setOpResultForPipe = void 0;
          if (!opResult) {
            throw new Error([
              "Cannot pipe StatefulEvt because the operator does not match",
              "it's current state. You would end up with evt.state === undefined",
              "Use evt.toStateless([ctx]).pipe(op).toStatic(initialState)",
              "to be sure the StatefulEvt does not have an undefined state"
            ].join(" "));
          }
          return evt.toStateful(opResult[0]);
        };
        StatefulEvtImpl2.prototype.toStateless = function(ctx) {
          var onAddHandler = Evt_2.onAddHandlerByEvt.get(this);
          Evt_2.onAddHandlerByEvt.delete(this);
          var out = !!ctx ? _super.prototype.pipe.call(this, ctx) : _super.prototype.pipe.call(this);
          Evt_2.onAddHandlerByEvt.set(this, onAddHandler);
          return out;
        };
        return StatefulEvtImpl2;
      }(Evt_2.Evt)
    );
    exports.StatefulEvt = StatefulEvtImpl;
    importProxy_1.importProxy.StatefulEvt = exports.StatefulEvt;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/operators/to.js
var require_to = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/operators/to.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.to = void 0;
    var map = /* @__PURE__ */ new Map();
    var to = /* @__PURE__ */ __name(function(eventName) {
      var _a;
      return (_a = map.get(eventName)) !== null && _a !== void 0 ? _a : (map.set(eventName, function(data) {
        return data[0] !== eventName ? null : [data[1]];
      }), (0, exports.to)(eventName));
    }, "to");
    exports.to = to;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/operators/throttleTime.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttleTime = void 0;
    var compose_1 = require_compose();
    var throttleTime = /* @__PURE__ */ __name(function(duration) {
      return (0, compose_1.compose)([
        function(data, _a) {
          var lastClick = _a.lastClick;
          var now = Date.now();
          return now - lastClick < duration ? null : [{ data, "lastClick": now }];
        },
        { "lastClick": 0, "data": null }
      ], function(_a) {
        var data = _a.data;
        return [data];
      });
    }, "throttleTime");
    exports.throttleTime = throttleTime;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/operators/nonNullable.js
var require_nonNullable = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/operators/nonNullable.js"(exports) {
    "use strict";
    init_esm();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nonNullable = void 0;
    var isNonNullable = /* @__PURE__ */ __name(function(arg) {
      return arg !== void 0 && arg !== null;
    }, "isNonNullable");
    var nonNullableImpl = /* @__PURE__ */ __name(function(data) {
      return !isNonNullable(data) ? null : [data];
    }, "nonNullableImpl");
    var nonNullable = /* @__PURE__ */ __name(function() {
      return nonNullableImpl;
    }, "nonNullable");
    exports.nonNullable = nonNullable;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/operators/distinct.js
var require_distinct = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/operators/distinct.js"(exports) {
    "use strict";
    init_esm();
    var __read = exports && exports.__read || function(o3, n) {
      var m = typeof Symbol === "function" && o3[Symbol.iterator];
      if (!m) return o3;
      var i = m.call(o3), r2, ar = [], e2;
      try {
        while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m = i["return"])) m.call(i);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinct = void 0;
    var compose_1 = require_compose();
    var distinct = /* @__PURE__ */ __name(function(keySelector, ctxFlush) {
      var _a;
      return (0, compose_1.compose)(function(data) {
        var _a2, _b;
        return [{
          data,
          "selectedKey": (_a2 = keySelector === null || keySelector === void 0 ? void 0 : keySelector(data)) !== null && _a2 !== void 0 ? _a2 : data,
          "currentFlushCount": (_b = ctxFlush === null || ctxFlush === void 0 ? void 0 : ctxFlush.evtDoneOrAborted.postCount) !== null && _b !== void 0 ? _b : 0
        }];
      }, [
        function(_a2, _b) {
          var data = _a2.data, selectedKey = _a2.selectedKey, currentFlushCount = _a2.currentFlushCount;
          var alreadyPostedData = _b.alreadyPostedData, previousFlushCount = _b.previousFlushCount;
          return [{
            "boxedData": currentFlushCount !== previousFlushCount || !alreadyPostedData.has(selectedKey) ? [data] : null,
            "alreadyPostedData": new Set(__spreadArray(__spreadArray([], __read(currentFlushCount !== previousFlushCount ? [] : Array.from(alreadyPostedData)), false), [
              selectedKey
            ], false)),
            "previousFlushCount": currentFlushCount
          }];
        },
        {
          "boxedData": null,
          "alreadyPostedData": /* @__PURE__ */ new Set(),
          "previousFlushCount": (_a = ctxFlush === null || ctxFlush === void 0 ? void 0 : ctxFlush.evtDoneOrAborted.postCount) !== null && _a !== void 0 ? _a : 0
        }
      ], function(_a2) {
        var boxedData = _a2.boxedData;
        return boxedData;
      });
    }, "distinct");
    exports.distinct = distinct;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/index.js
var require_lib = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/evt/lib/index.js"(exports) {
    "use strict";
    init_esm();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k2];
        }, "get") };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o3[k22] = m[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinct = exports.nonNullable = exports.throttleTime = exports.to = exports.StatefulEvt = exports.Evt = exports.Ctx = void 0;
    __exportStar(require_types(), exports);
    __exportStar(require_util(), exports);
    var Ctx_1 = require_Ctx();
    Object.defineProperty(exports, "Ctx", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Ctx_1.Ctx;
    }, "get") });
    var Evt_2 = require_Evt();
    Object.defineProperty(exports, "Evt", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Evt_2.Evt;
    }, "get") });
    var StatefulEvt_1 = require_StatefulEvt();
    Object.defineProperty(exports, "StatefulEvt", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return StatefulEvt_1.StatefulEvt;
    }, "get") });
    var to_1 = require_to();
    Object.defineProperty(exports, "to", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return to_1.to;
    }, "get") });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports, "throttleTime", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return throttleTime_1.throttleTime;
    }, "get") });
    var nonNullable_1 = require_nonNullable();
    Object.defineProperty(exports, "nonNullable", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return nonNullable_1.nonNullable;
    }, "get") });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports, "distinct", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return distinct_1.distinct;
    }, "get") });
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/sisteransi/src/index.js
var require_src = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/sisteransi/src/index.js"(exports, module) {
    "use strict";
    init_esm();
    var ESC2 = "\x1B";
    var CSI = `${ESC2}[`;
    var beep2 = "\x07";
    var cursor = {
      to(x, y2) {
        if (!y2) return `${CSI}${x + 1}G`;
        return `${CSI}${y2 + 1};${x + 1}H`;
      },
      move(x, y2) {
        let ret = "";
        if (x < 0) ret += `${CSI}${-x}D`;
        else if (x > 0) ret += `${CSI}${x}C`;
        if (y2 < 0) ret += `${CSI}${-y2}A`;
        else if (y2 > 0) ret += `${CSI}${y2}B`;
        return ret;
      },
      up: /* @__PURE__ */ __name((count = 1) => `${CSI}${count}A`, "up"),
      down: /* @__PURE__ */ __name((count = 1) => `${CSI}${count}B`, "down"),
      forward: /* @__PURE__ */ __name((count = 1) => `${CSI}${count}C`, "forward"),
      backward: /* @__PURE__ */ __name((count = 1) => `${CSI}${count}D`, "backward"),
      nextLine: /* @__PURE__ */ __name((count = 1) => `${CSI}E`.repeat(count), "nextLine"),
      prevLine: /* @__PURE__ */ __name((count = 1) => `${CSI}F`.repeat(count), "prevLine"),
      left: `${CSI}G`,
      hide: `${CSI}?25l`,
      show: `${CSI}?25h`,
      save: `${ESC2}7`,
      restore: `${ESC2}8`
    };
    var scroll = {
      up: /* @__PURE__ */ __name((count = 1) => `${CSI}S`.repeat(count), "up"),
      down: /* @__PURE__ */ __name((count = 1) => `${CSI}T`.repeat(count), "down")
    };
    var erase = {
      screen: `${CSI}2J`,
      up: /* @__PURE__ */ __name((count = 1) => `${CSI}1J`.repeat(count), "up"),
      down: /* @__PURE__ */ __name((count = 1) => `${CSI}J`.repeat(count), "down"),
      line: `${CSI}2K`,
      lineEnd: `${CSI}K`,
      lineStart: `${CSI}1K`,
      lines(count) {
        let clear = "";
        for (let i = 0; i < count; i++)
          clear += this.line + (i < count - 1 ? cursor.up() : "");
        if (count)
          clear += cursor.left;
        return clear;
      }
    };
    module.exports = { cursor, scroll, erase, beep: beep2 };
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "../../.npm/_npx/f51a09bd0abf5f10/node_modules/picocolors/picocolors.js"(exports, module) {
    init_esm();
    var p = process || {};
    var argv = p.argv || [];
    var env = p.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = /* @__PURE__ */ __name((open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    }, "formatter");
    var replaceClose = /* @__PURE__ */ __name((string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    }, "replaceClose");
    var createColors = /* @__PURE__ */ __name((enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    }, "createColors");
    module.exports = createColors();
    module.exports.createColors = createColors;
  }
});

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed-run-controller.js
init_esm();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/utilities/fileSystem.js
init_esm();
import fsModule from "fs/promises";
async function readJSONFile(path) {
  const fileContents = await fsModule.readFile(path, "utf8");
  return JSON.parse(fileContents);
}
__name(readJSONFile, "readJSONFile");

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/controller.js
init_esm();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/env.js
init_esm();
import { randomUUID } from "node:crypto";
var DateEnv = external_exports.string().transform((val) => new Date(parseInt(val, 10))).pipe(external_exports.date());
var Env = external_exports.object({
  // Set at build time
  TRIGGER_CONTENT_HASH: external_exports.string(),
  TRIGGER_DEPLOYMENT_ID: external_exports.string(),
  TRIGGER_DEPLOYMENT_VERSION: external_exports.string(),
  TRIGGER_PROJECT_ID: external_exports.string(),
  TRIGGER_PROJECT_REF: external_exports.string(),
  NODE_ENV: external_exports.string().default("production"),
  NODE_EXTRA_CA_CERTS: external_exports.string().optional(),
  UV_USE_IO_URING: external_exports.string().optional(),
  // Set at runtime
  TRIGGER_WORKLOAD_CONTROLLER_ID: external_exports.string().default(`controller_${randomUUID()}`),
  TRIGGER_ENV_ID: external_exports.string(),
  OTEL_EXPORTER_OTLP_ENDPOINT: external_exports.string().url(),
  TRIGGER_WARM_START_URL: external_exports.string().optional(),
  TRIGGER_WARM_START_CONNECTION_TIMEOUT_MS: external_exports.coerce.number().default(3e4),
  TRIGGER_WARM_START_KEEPALIVE_MS: external_exports.coerce.number().default(3e5),
  TRIGGER_MACHINE_CPU: external_exports.string().default("0"),
  TRIGGER_MACHINE_MEMORY: external_exports.string().default("0"),
  TRIGGER_RUNNER_ID: external_exports.string(),
  TRIGGER_METADATA_URL: external_exports.string().optional(),
  // Timeline metrics
  TRIGGER_POD_SCHEDULED_AT_MS: DateEnv,
  TRIGGER_DEQUEUED_AT_MS: DateEnv,
  // May be overridden
  TRIGGER_RUN_ID: external_exports.string().optional(),
  // This is set for cold starts and restores
  TRIGGER_SNAPSHOT_ID: external_exports.string().optional(),
  // This is set for cold starts and restores
  TRIGGER_SUPERVISOR_API_PROTOCOL: external_exports.enum(["http", "https"]),
  TRIGGER_SUPERVISOR_API_DOMAIN: external_exports.string(),
  TRIGGER_SUPERVISOR_API_PORT: external_exports.coerce.number(),
  TRIGGER_WORKER_INSTANCE_NAME: external_exports.string(),
  TRIGGER_HEARTBEAT_INTERVAL_SECONDS: external_exports.coerce.number().default(20),
  TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS: external_exports.coerce.number().default(5),
  TRIGGER_SUCCESS_EXIT_CODE: external_exports.coerce.number().default(0),
  TRIGGER_FAILURE_EXIT_CODE: external_exports.coerce.number().default(1)
});
var RunnerEnv = class {
  static {
    __name(this, "RunnerEnv");
  }
  env;
  initial;
  constructor(env) {
    this.env = Env.parse(env);
    this.initial = { ...this.env };
  }
  get raw() {
    return this.env;
  }
  // Base environment variables
  get NODE_ENV() {
    return this.env.NODE_ENV;
  }
  get NODE_EXTRA_CA_CERTS() {
    return this.env.NODE_EXTRA_CA_CERTS;
  }
  get UV_USE_IO_URING() {
    return this.env.UV_USE_IO_URING;
  }
  get OTEL_EXPORTER_OTLP_ENDPOINT() {
    return this.env.OTEL_EXPORTER_OTLP_ENDPOINT;
  }
  get TRIGGER_CONTENT_HASH() {
    return this.env.TRIGGER_CONTENT_HASH;
  }
  get TRIGGER_DEPLOYMENT_ID() {
    return this.env.TRIGGER_DEPLOYMENT_ID;
  }
  get TRIGGER_DEPLOYMENT_VERSION() {
    return this.env.TRIGGER_DEPLOYMENT_VERSION;
  }
  get TRIGGER_PROJECT_ID() {
    return this.env.TRIGGER_PROJECT_ID;
  }
  get TRIGGER_PROJECT_REF() {
    return this.env.TRIGGER_PROJECT_REF;
  }
  get TRIGGER_WORKLOAD_CONTROLLER_ID() {
    return this.env.TRIGGER_WORKLOAD_CONTROLLER_ID;
  }
  get TRIGGER_ENV_ID() {
    return this.env.TRIGGER_ENV_ID;
  }
  get TRIGGER_WARM_START_URL() {
    return this.env.TRIGGER_WARM_START_URL;
  }
  get TRIGGER_WARM_START_CONNECTION_TIMEOUT_MS() {
    return this.env.TRIGGER_WARM_START_CONNECTION_TIMEOUT_MS;
  }
  get TRIGGER_WARM_START_KEEPALIVE_MS() {
    return this.env.TRIGGER_WARM_START_KEEPALIVE_MS;
  }
  get TRIGGER_MACHINE_CPU() {
    return this.env.TRIGGER_MACHINE_CPU;
  }
  get TRIGGER_MACHINE_MEMORY() {
    return this.env.TRIGGER_MACHINE_MEMORY;
  }
  get TRIGGER_METADATA_URL() {
    return this.env.TRIGGER_METADATA_URL;
  }
  get TRIGGER_POD_SCHEDULED_AT_MS() {
    return this.env.TRIGGER_POD_SCHEDULED_AT_MS;
  }
  get TRIGGER_DEQUEUED_AT_MS() {
    return this.env.TRIGGER_DEQUEUED_AT_MS;
  }
  // Overridable values
  get TRIGGER_RUN_ID() {
    return this.env.TRIGGER_RUN_ID;
  }
  get TRIGGER_SNAPSHOT_ID() {
    return this.env.TRIGGER_SNAPSHOT_ID;
  }
  get TRIGGER_SUCCESS_EXIT_CODE() {
    return this.env.TRIGGER_SUCCESS_EXIT_CODE;
  }
  get TRIGGER_FAILURE_EXIT_CODE() {
    return this.env.TRIGGER_FAILURE_EXIT_CODE;
  }
  get TRIGGER_HEARTBEAT_INTERVAL_SECONDS() {
    return this.env.TRIGGER_HEARTBEAT_INTERVAL_SECONDS;
  }
  get TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS() {
    return this.env.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS;
  }
  get TRIGGER_WORKER_INSTANCE_NAME() {
    return this.env.TRIGGER_WORKER_INSTANCE_NAME;
  }
  get TRIGGER_RUNNER_ID() {
    return this.env.TRIGGER_RUNNER_ID;
  }
  get TRIGGER_SUPERVISOR_API_PROTOCOL() {
    return this.env.TRIGGER_SUPERVISOR_API_PROTOCOL;
  }
  get TRIGGER_SUPERVISOR_API_DOMAIN() {
    return this.env.TRIGGER_SUPERVISOR_API_DOMAIN;
  }
  get TRIGGER_SUPERVISOR_API_PORT() {
    return this.env.TRIGGER_SUPERVISOR_API_PORT;
  }
  get TRIGGER_SUPERVISOR_API_URL() {
    return `${this.TRIGGER_SUPERVISOR_API_PROTOCOL}://${this.TRIGGER_SUPERVISOR_API_DOMAIN}:${this.TRIGGER_SUPERVISOR_API_PORT}`;
  }
  /** Overrides existing env vars with new values */
  override(overrides) {
    if (overrides.TRIGGER_RUN_ID) {
      this.env.TRIGGER_RUN_ID = overrides.TRIGGER_RUN_ID;
    }
    if (overrides.TRIGGER_SNAPSHOT_ID) {
      this.env.TRIGGER_SNAPSHOT_ID = overrides.TRIGGER_SNAPSHOT_ID;
    }
    if (overrides.TRIGGER_SUCCESS_EXIT_CODE) {
      this.env.TRIGGER_SUCCESS_EXIT_CODE = overrides.TRIGGER_SUCCESS_EXIT_CODE;
    }
    if (overrides.TRIGGER_FAILURE_EXIT_CODE) {
      this.env.TRIGGER_FAILURE_EXIT_CODE = overrides.TRIGGER_FAILURE_EXIT_CODE;
    }
    if (overrides.TRIGGER_HEARTBEAT_INTERVAL_SECONDS) {
      this.env.TRIGGER_HEARTBEAT_INTERVAL_SECONDS = overrides.TRIGGER_HEARTBEAT_INTERVAL_SECONDS;
    }
    if (overrides.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS) {
      this.env.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS = overrides.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS;
    }
    if (overrides.TRIGGER_WORKER_INSTANCE_NAME) {
      this.env.TRIGGER_WORKER_INSTANCE_NAME = overrides.TRIGGER_WORKER_INSTANCE_NAME;
    }
    if (overrides.TRIGGER_SUPERVISOR_API_PROTOCOL) {
      this.env.TRIGGER_SUPERVISOR_API_PROTOCOL = overrides.TRIGGER_SUPERVISOR_API_PROTOCOL;
    }
    if (overrides.TRIGGER_SUPERVISOR_API_DOMAIN) {
      this.env.TRIGGER_SUPERVISOR_API_DOMAIN = overrides.TRIGGER_SUPERVISOR_API_DOMAIN;
    }
    if (overrides.TRIGGER_SUPERVISOR_API_PORT) {
      this.env.TRIGGER_SUPERVISOR_API_PORT = overrides.TRIGGER_SUPERVISOR_API_PORT;
    }
    if (overrides.TRIGGER_RUNNER_ID) {
      this.env.TRIGGER_RUNNER_ID = overrides.TRIGGER_RUNNER_ID;
    }
  }
  // Helper method to get process env for task runs
  gatherProcessEnv() {
    const $env = {
      NODE_ENV: this.NODE_ENV,
      NODE_EXTRA_CA_CERTS: this.NODE_EXTRA_CA_CERTS,
      OTEL_EXPORTER_OTLP_ENDPOINT: this.OTEL_EXPORTER_OTLP_ENDPOINT,
      TRIGGER_OTEL_EXPORTER_OTLP_ENDPOINT: this.OTEL_EXPORTER_OTLP_ENDPOINT,
      UV_USE_IO_URING: this.UV_USE_IO_URING
    };
    return Object.fromEntries(Object.entries($env).filter(([key, value]) => value !== void 0));
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/logger.js
init_esm();
var ManagedRunLogger = class {
  static {
    __name(this, "ManagedRunLogger");
  }
  httpClient;
  env;
  logger;
  constructor(opts) {
    this.httpClient = opts.httpClient;
    this.env = opts.env;
    this.logger = new SimpleStructuredLogger("managed-run-logger");
  }
  sendDebugLog({ runId, message, date, properties, print = true }) {
    if (!runId) {
      runId = this.env.TRIGGER_RUN_ID;
    }
    if (!runId) {
      return;
    }
    const mergedProperties = {
      ...properties,
      runId,
      runnerId: this.env.TRIGGER_RUNNER_ID,
      workerName: this.env.TRIGGER_WORKER_INSTANCE_NAME
    };
    if (print) {
      this.logger.log(message, mergedProperties);
    }
    const flattenedProperties = flattenAttributes(mergedProperties);
    this.httpClient.sendDebugLog(runId, {
      message,
      time: date ?? /* @__PURE__ */ new Date(),
      properties: flattenedProperties
    });
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/execution.js
init_esm();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/executions/taskRunProcess.js
init_esm();
var import_evt = __toESM(require_lib(), 1);
import { fork } from "node:child_process";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/utilities/cliOutput.js
init_esm();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/@clack/prompts/dist/index.mjs
init_esm();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/@clack/core/dist/index.mjs
init_esm();
var import_sisteransi = __toESM(require_src(), 1);
function DD({ onlyFirst: e2 = false } = {}) {
  const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(t, e2 ? void 0 : "g");
}
__name(DD, "DD");
var uD = DD();
function L(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
__name(L, "L");
var W = { exports: {} };
(function(e2) {
  var u2 = {};
  e2.exports = u2, u2.eastAsianWidth = function(F2) {
    var s = F2.charCodeAt(0), i = F2.length == 2 ? F2.charCodeAt(1) : 0, D2 = s;
    return 55296 <= s && s <= 56319 && 56320 <= i && i <= 57343 && (s &= 1023, i &= 1023, D2 = s << 10 | i, D2 += 65536), D2 == 12288 || 65281 <= D2 && D2 <= 65376 || 65504 <= D2 && D2 <= 65510 ? "F" : D2 == 8361 || 65377 <= D2 && D2 <= 65470 || 65474 <= D2 && D2 <= 65479 || 65482 <= D2 && D2 <= 65487 || 65490 <= D2 && D2 <= 65495 || 65498 <= D2 && D2 <= 65500 || 65512 <= D2 && D2 <= 65518 ? "H" : 4352 <= D2 && D2 <= 4447 || 4515 <= D2 && D2 <= 4519 || 4602 <= D2 && D2 <= 4607 || 9001 <= D2 && D2 <= 9002 || 11904 <= D2 && D2 <= 11929 || 11931 <= D2 && D2 <= 12019 || 12032 <= D2 && D2 <= 12245 || 12272 <= D2 && D2 <= 12283 || 12289 <= D2 && D2 <= 12350 || 12353 <= D2 && D2 <= 12438 || 12441 <= D2 && D2 <= 12543 || 12549 <= D2 && D2 <= 12589 || 12593 <= D2 && D2 <= 12686 || 12688 <= D2 && D2 <= 12730 || 12736 <= D2 && D2 <= 12771 || 12784 <= D2 && D2 <= 12830 || 12832 <= D2 && D2 <= 12871 || 12880 <= D2 && D2 <= 13054 || 13056 <= D2 && D2 <= 19903 || 19968 <= D2 && D2 <= 42124 || 42128 <= D2 && D2 <= 42182 || 43360 <= D2 && D2 <= 43388 || 44032 <= D2 && D2 <= 55203 || 55216 <= D2 && D2 <= 55238 || 55243 <= D2 && D2 <= 55291 || 63744 <= D2 && D2 <= 64255 || 65040 <= D2 && D2 <= 65049 || 65072 <= D2 && D2 <= 65106 || 65108 <= D2 && D2 <= 65126 || 65128 <= D2 && D2 <= 65131 || 110592 <= D2 && D2 <= 110593 || 127488 <= D2 && D2 <= 127490 || 127504 <= D2 && D2 <= 127546 || 127552 <= D2 && D2 <= 127560 || 127568 <= D2 && D2 <= 127569 || 131072 <= D2 && D2 <= 194367 || 177984 <= D2 && D2 <= 196605 || 196608 <= D2 && D2 <= 262141 ? "W" : 32 <= D2 && D2 <= 126 || 162 <= D2 && D2 <= 163 || 165 <= D2 && D2 <= 166 || D2 == 172 || D2 == 175 || 10214 <= D2 && D2 <= 10221 || 10629 <= D2 && D2 <= 10630 ? "Na" : D2 == 161 || D2 == 164 || 167 <= D2 && D2 <= 168 || D2 == 170 || 173 <= D2 && D2 <= 174 || 176 <= D2 && D2 <= 180 || 182 <= D2 && D2 <= 186 || 188 <= D2 && D2 <= 191 || D2 == 198 || D2 == 208 || 215 <= D2 && D2 <= 216 || 222 <= D2 && D2 <= 225 || D2 == 230 || 232 <= D2 && D2 <= 234 || 236 <= D2 && D2 <= 237 || D2 == 240 || 242 <= D2 && D2 <= 243 || 247 <= D2 && D2 <= 250 || D2 == 252 || D2 == 254 || D2 == 257 || D2 == 273 || D2 == 275 || D2 == 283 || 294 <= D2 && D2 <= 295 || D2 == 299 || 305 <= D2 && D2 <= 307 || D2 == 312 || 319 <= D2 && D2 <= 322 || D2 == 324 || 328 <= D2 && D2 <= 331 || D2 == 333 || 338 <= D2 && D2 <= 339 || 358 <= D2 && D2 <= 359 || D2 == 363 || D2 == 462 || D2 == 464 || D2 == 466 || D2 == 468 || D2 == 470 || D2 == 472 || D2 == 474 || D2 == 476 || D2 == 593 || D2 == 609 || D2 == 708 || D2 == 711 || 713 <= D2 && D2 <= 715 || D2 == 717 || D2 == 720 || 728 <= D2 && D2 <= 731 || D2 == 733 || D2 == 735 || 768 <= D2 && D2 <= 879 || 913 <= D2 && D2 <= 929 || 931 <= D2 && D2 <= 937 || 945 <= D2 && D2 <= 961 || 963 <= D2 && D2 <= 969 || D2 == 1025 || 1040 <= D2 && D2 <= 1103 || D2 == 1105 || D2 == 8208 || 8211 <= D2 && D2 <= 8214 || 8216 <= D2 && D2 <= 8217 || 8220 <= D2 && D2 <= 8221 || 8224 <= D2 && D2 <= 8226 || 8228 <= D2 && D2 <= 8231 || D2 == 8240 || 8242 <= D2 && D2 <= 8243 || D2 == 8245 || D2 == 8251 || D2 == 8254 || D2 == 8308 || D2 == 8319 || 8321 <= D2 && D2 <= 8324 || D2 == 8364 || D2 == 8451 || D2 == 8453 || D2 == 8457 || D2 == 8467 || D2 == 8470 || 8481 <= D2 && D2 <= 8482 || D2 == 8486 || D2 == 8491 || 8531 <= D2 && D2 <= 8532 || 8539 <= D2 && D2 <= 8542 || 8544 <= D2 && D2 <= 8555 || 8560 <= D2 && D2 <= 8569 || D2 == 8585 || 8592 <= D2 && D2 <= 8601 || 8632 <= D2 && D2 <= 8633 || D2 == 8658 || D2 == 8660 || D2 == 8679 || D2 == 8704 || 8706 <= D2 && D2 <= 8707 || 8711 <= D2 && D2 <= 8712 || D2 == 8715 || D2 == 8719 || D2 == 8721 || D2 == 8725 || D2 == 8730 || 8733 <= D2 && D2 <= 8736 || D2 == 8739 || D2 == 8741 || 8743 <= D2 && D2 <= 8748 || D2 == 8750 || 8756 <= D2 && D2 <= 8759 || 8764 <= D2 && D2 <= 8765 || D2 == 8776 || D2 == 8780 || D2 == 8786 || 8800 <= D2 && D2 <= 8801 || 8804 <= D2 && D2 <= 8807 || 8810 <= D2 && D2 <= 8811 || 8814 <= D2 && D2 <= 8815 || 8834 <= D2 && D2 <= 8835 || 8838 <= D2 && D2 <= 8839 || D2 == 8853 || D2 == 8857 || D2 == 8869 || D2 == 8895 || D2 == 8978 || 9312 <= D2 && D2 <= 9449 || 9451 <= D2 && D2 <= 9547 || 9552 <= D2 && D2 <= 9587 || 9600 <= D2 && D2 <= 9615 || 9618 <= D2 && D2 <= 9621 || 9632 <= D2 && D2 <= 9633 || 9635 <= D2 && D2 <= 9641 || 9650 <= D2 && D2 <= 9651 || 9654 <= D2 && D2 <= 9655 || 9660 <= D2 && D2 <= 9661 || 9664 <= D2 && D2 <= 9665 || 9670 <= D2 && D2 <= 9672 || D2 == 9675 || 9678 <= D2 && D2 <= 9681 || 9698 <= D2 && D2 <= 9701 || D2 == 9711 || 9733 <= D2 && D2 <= 9734 || D2 == 9737 || 9742 <= D2 && D2 <= 9743 || 9748 <= D2 && D2 <= 9749 || D2 == 9756 || D2 == 9758 || D2 == 9792 || D2 == 9794 || 9824 <= D2 && D2 <= 9825 || 9827 <= D2 && D2 <= 9829 || 9831 <= D2 && D2 <= 9834 || 9836 <= D2 && D2 <= 9837 || D2 == 9839 || 9886 <= D2 && D2 <= 9887 || 9918 <= D2 && D2 <= 9919 || 9924 <= D2 && D2 <= 9933 || 9935 <= D2 && D2 <= 9953 || D2 == 9955 || 9960 <= D2 && D2 <= 9983 || D2 == 10045 || D2 == 10071 || 10102 <= D2 && D2 <= 10111 || 11093 <= D2 && D2 <= 11097 || 12872 <= D2 && D2 <= 12879 || 57344 <= D2 && D2 <= 63743 || 65024 <= D2 && D2 <= 65039 || D2 == 65533 || 127232 <= D2 && D2 <= 127242 || 127248 <= D2 && D2 <= 127277 || 127280 <= D2 && D2 <= 127337 || 127344 <= D2 && D2 <= 127386 || 917760 <= D2 && D2 <= 917999 || 983040 <= D2 && D2 <= 1048573 || 1048576 <= D2 && D2 <= 1114109 ? "A" : "N";
  }, u2.characterLength = function(F2) {
    var s = this.eastAsianWidth(F2);
    return s == "F" || s == "W" || s == "A" ? 2 : 1;
  };
  function t(F2) {
    return F2.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  __name(t, "t");
  u2.length = function(F2) {
    for (var s = t(F2), i = 0, D2 = 0; D2 < s.length; D2++) i = i + this.characterLength(s[D2]);
    return i;
  }, u2.slice = function(F2, s, i) {
    textLen = u2.length(F2), s = s || 0, i = i || 1, s < 0 && (s = textLen + s), i < 0 && (i = textLen + i);
    for (var D2 = "", C2 = 0, n = t(F2), E = 0; E < n.length; E++) {
      var a = n[E], o3 = u2.length(a);
      if (C2 >= s - (o3 == 2 ? 1 : 0)) if (C2 + o3 <= i) D2 += a;
      else break;
      C2 += o3;
    }
    return D2;
  };
})(W);
var tD = W.exports;
var eD = L(tD);
var FD = /* @__PURE__ */ __name(function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
}, "FD");
var sD = L(FD);
var w = 10;
var N = /* @__PURE__ */ __name((e2 = 0) => (u2) => `\x1B[${u2 + e2}m`, "N");
var I = /* @__PURE__ */ __name((e2 = 0) => (u2) => `\x1B[${38 + e2};5;${u2}m`, "I");
var R = /* @__PURE__ */ __name((e2 = 0) => (u2, t, F2) => `\x1B[${38 + e2};2;${u2};${t};${F2}m`, "R");
var r = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
Object.keys(r.modifier);
var iD = Object.keys(r.color);
var CD = Object.keys(r.bgColor);
[...iD, ...CD];
function rD() {
  const e2 = /* @__PURE__ */ new Map();
  for (const [u2, t] of Object.entries(r)) {
    for (const [F2, s] of Object.entries(t)) r[F2] = { open: `\x1B[${s[0]}m`, close: `\x1B[${s[1]}m` }, t[F2] = r[F2], e2.set(s[0], s[1]);
    Object.defineProperty(r, u2, { value: t, enumerable: false });
  }
  return Object.defineProperty(r, "codes", { value: e2, enumerable: false }), r.color.close = "\x1B[39m", r.bgColor.close = "\x1B[49m", r.color.ansi = N(), r.color.ansi256 = I(), r.color.ansi16m = R(), r.bgColor.ansi = N(w), r.bgColor.ansi256 = I(w), r.bgColor.ansi16m = R(w), Object.defineProperties(r, { rgbToAnsi256: { value: /* @__PURE__ */ __name((u2, t, F2) => u2 === t && t === F2 ? u2 < 8 ? 16 : u2 > 248 ? 231 : Math.round((u2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u2 / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(F2 / 255 * 5), "value"), enumerable: false }, hexToRgb: { value: /* @__PURE__ */ __name((u2) => {
    const t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u2.toString(16));
    if (!t) return [0, 0, 0];
    let [F2] = t;
    F2.length === 3 && (F2 = [...F2].map((i) => i + i).join(""));
    const s = Number.parseInt(F2, 16);
    return [s >> 16 & 255, s >> 8 & 255, s & 255];
  }, "value"), enumerable: false }, hexToAnsi256: { value: /* @__PURE__ */ __name((u2) => r.rgbToAnsi256(...r.hexToRgb(u2)), "value"), enumerable: false }, ansi256ToAnsi: { value: /* @__PURE__ */ __name((u2) => {
    if (u2 < 8) return 30 + u2;
    if (u2 < 16) return 90 + (u2 - 8);
    let t, F2, s;
    if (u2 >= 232) t = ((u2 - 232) * 10 + 8) / 255, F2 = t, s = t;
    else {
      u2 -= 16;
      const C2 = u2 % 36;
      t = Math.floor(u2 / 36) / 5, F2 = Math.floor(C2 / 6) / 5, s = C2 % 6 / 5;
    }
    const i = Math.max(t, F2, s) * 2;
    if (i === 0) return 30;
    let D2 = 30 + (Math.round(s) << 2 | Math.round(F2) << 1 | Math.round(t));
    return i === 2 && (D2 += 60), D2;
  }, "value"), enumerable: false }, rgbToAnsi: { value: /* @__PURE__ */ __name((u2, t, F2) => r.ansi256ToAnsi(r.rgbToAnsi256(u2, t, F2)), "value"), enumerable: false }, hexToAnsi: { value: /* @__PURE__ */ __name((u2) => r.ansi256ToAnsi(r.hexToAnsi256(u2)), "value"), enumerable: false } }), r;
}
__name(rD, "rD");
var ED = rD();
var nD = "]";
var _ = `${nD}8;;`;
var xD = ["up", "down", "left", "right", "space", "enter", "cancel"];
var B = { actions: new Set(xD), aliases: /* @__PURE__ */ new Map([["k", "up"], ["j", "down"], ["h", "left"], ["l", "right"], ["", "cancel"], ["escape", "cancel"]]) };
var AD = globalThis.process.platform.startsWith("win");
var S = Symbol("clack:cancel");
var A;
A = /* @__PURE__ */ new WeakMap();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/@clack/prompts/dist/index.mjs
var import_picocolors = __toESM(require_picocolors(), 1);
var import_sisteransi2 = __toESM(require_src(), 1);
import y from "node:process";
function ce() {
  return y.platform !== "win32" ? y.env.TERM !== "linux" : !!y.env.CI || !!y.env.WT_SESSION || !!y.env.TERMINUS_SUBLIME || y.env.ConEmuTask === "{cmd::Cmder}" || y.env.TERM_PROGRAM === "Terminus-Sublime" || y.env.TERM_PROGRAM === "vscode" || y.env.TERM === "xterm-256color" || y.env.TERM === "alacritty" || y.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
__name(ce, "ce");
var V = ce();
var u = /* @__PURE__ */ __name((t, n) => V ? t : n, "u");
var le = u("◆", "*");
var L2 = u("■", "x");
var W2 = u("▲", "x");
var C = u("◇", "o");
var ue = u("┌", "T");
var o2 = u("│", "|");
var d = u("└", "—");
var k = u("●", ">");
var P = u("○", " ");
var A2 = u("◻", "[•]");
var T = u("◼", "[+]");
var F = u("◻", "[ ]");
var $e = u("▪", "•");
var _2 = u("─", "-");
var me = u("╮", "+");
var de = u("├", "+");
var pe = u("╯", "+");
var q = u("●", "•");
var D = u("◆", "*");
var U = u("▲", "!");
var K = u("■", "x");
var J = `${import_picocolors.default.gray(o2)}  `;

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/utilities/terminalLink.js
init_esm();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/ansi-escapes/index.js
init_esm();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/ansi-escapes/base.js
var base_exports = {};
__export(base_exports, {
  ConEmu: () => ConEmu,
  beep: () => beep,
  clearScreen: () => clearScreen,
  clearTerminal: () => clearTerminal,
  clearViewport: () => clearViewport,
  cursorBackward: () => cursorBackward,
  cursorDown: () => cursorDown,
  cursorForward: () => cursorForward,
  cursorGetPosition: () => cursorGetPosition,
  cursorHide: () => cursorHide,
  cursorLeft: () => cursorLeft,
  cursorMove: () => cursorMove,
  cursorNextLine: () => cursorNextLine,
  cursorPrevLine: () => cursorPrevLine,
  cursorRestorePosition: () => cursorRestorePosition,
  cursorSavePosition: () => cursorSavePosition,
  cursorShow: () => cursorShow,
  cursorTo: () => cursorTo,
  cursorUp: () => cursorUp,
  enterAlternativeScreen: () => enterAlternativeScreen,
  eraseDown: () => eraseDown,
  eraseEndLine: () => eraseEndLine,
  eraseLine: () => eraseLine,
  eraseLines: () => eraseLines,
  eraseScreen: () => eraseScreen,
  eraseStartLine: () => eraseStartLine,
  eraseUp: () => eraseUp,
  exitAlternativeScreen: () => exitAlternativeScreen,
  iTerm: () => iTerm,
  image: () => image,
  link: () => link,
  scrollDown: () => scrollDown,
  scrollUp: () => scrollUp,
  setCwd: () => setCwd
});
init_esm();
import process2 from "node:process";
import os from "node:os";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/environment/index.js
init_esm();
var isBrowser = globalThis.window?.document !== void 0;
var isNode = globalThis.process?.versions?.node !== void 0;
var isBun = globalThis.process?.versions?.bun !== void 0;
var isDeno = globalThis.Deno?.version?.deno !== void 0;
var isElectron = globalThis.process?.versions?.electron !== void 0;
var isJsDom = globalThis.navigator?.userAgent?.includes("jsdom") === true;
var isWebWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var isDedicatedWorker = typeof DedicatedWorkerGlobalScope !== "undefined" && globalThis instanceof DedicatedWorkerGlobalScope;
var isSharedWorker = typeof SharedWorkerGlobalScope !== "undefined" && globalThis instanceof SharedWorkerGlobalScope;
var isServiceWorker = typeof ServiceWorkerGlobalScope !== "undefined" && globalThis instanceof ServiceWorkerGlobalScope;
var platform = globalThis.navigator?.userAgentData?.platform;
var isMacOs = platform === "macOS" || globalThis.navigator?.platform === "MacIntel" || globalThis.navigator?.userAgent?.includes(" Mac ") === true || globalThis.process?.platform === "darwin";
var isWindows = platform === "Windows" || globalThis.navigator?.platform === "Win32" || globalThis.process?.platform === "win32";
var isLinux = platform === "Linux" || globalThis.navigator?.platform?.startsWith("Linux") === true || globalThis.navigator?.userAgent?.includes(" Linux ") === true || globalThis.process?.platform === "linux";
var isIos = platform === "iOS" || globalThis.navigator?.platform === "MacIntel" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);
var isAndroid = platform === "Android" || globalThis.navigator?.platform === "Android" || globalThis.navigator?.userAgent?.includes(" Android ") === true || globalThis.process?.platform === "android";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/ansi-escapes/base.js
var ESC = "\x1B[";
var OSC = "\x1B]";
var BEL = "\x07";
var SEP = ";";
var isTerminalApp = !isBrowser && process2.env.TERM_PROGRAM === "Apple_Terminal";
var isWindows2 = !isBrowser && process2.platform === "win32";
var isTmux = !isBrowser && (process2.env.TERM?.startsWith("screen") || process2.env.TERM?.startsWith("tmux") || process2.env.TMUX !== void 0);
var cwdFunction = isBrowser ? () => {
  throw new Error("`process.cwd()` only works in Node.js, not the browser.");
} : process2.cwd;
var wrapOsc = /* @__PURE__ */ __name((sequence) => {
  if (isTmux) {
    return "\x1BPtmux;" + sequence.replaceAll("\x1B", "\x1B\x1B") + "\x1B\\";
  }
  return sequence;
}, "wrapOsc");
var cursorTo = /* @__PURE__ */ __name((x, y2) => {
  if (typeof x !== "number") {
    throw new TypeError("The `x` argument is required");
  }
  if (typeof y2 !== "number") {
    return ESC + (x + 1) + "G";
  }
  return ESC + (y2 + 1) + SEP + (x + 1) + "H";
}, "cursorTo");
var cursorMove = /* @__PURE__ */ __name((x, y2) => {
  if (typeof x !== "number") {
    throw new TypeError("The `x` argument is required");
  }
  let returnValue = "";
  if (x < 0) {
    returnValue += ESC + -x + "D";
  } else if (x > 0) {
    returnValue += ESC + x + "C";
  }
  if (y2 < 0) {
    returnValue += ESC + -y2 + "A";
  } else if (y2 > 0) {
    returnValue += ESC + y2 + "B";
  }
  return returnValue;
}, "cursorMove");
var cursorUp = /* @__PURE__ */ __name((count = 1) => ESC + count + "A", "cursorUp");
var cursorDown = /* @__PURE__ */ __name((count = 1) => ESC + count + "B", "cursorDown");
var cursorForward = /* @__PURE__ */ __name((count = 1) => ESC + count + "C", "cursorForward");
var cursorBackward = /* @__PURE__ */ __name((count = 1) => ESC + count + "D", "cursorBackward");
var cursorLeft = ESC + "G";
var cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
var cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
var cursorGetPosition = ESC + "6n";
var cursorNextLine = ESC + "E";
var cursorPrevLine = ESC + "F";
var cursorHide = ESC + "?25l";
var cursorShow = ESC + "?25h";
var eraseLines = /* @__PURE__ */ __name((count) => {
  let clear = "";
  for (let i = 0; i < count; i++) {
    clear += eraseLine + (i < count - 1 ? cursorUp() : "");
  }
  if (count) {
    clear += cursorLeft;
  }
  return clear;
}, "eraseLines");
var eraseEndLine = ESC + "K";
var eraseStartLine = ESC + "1K";
var eraseLine = ESC + "2K";
var eraseDown = ESC + "J";
var eraseUp = ESC + "1J";
var eraseScreen = ESC + "2J";
var scrollUp = ESC + "S";
var scrollDown = ESC + "T";
var clearScreen = "\x1Bc";
var clearViewport = `${eraseScreen}${ESC}H`;
var isOldWindows = /* @__PURE__ */ __name(() => {
  if (isBrowser || !isWindows2) {
    return false;
  }
  const parts = os.release().split(".");
  const major = Number(parts[0]);
  const build = Number(parts[2] ?? 0);
  if (major < 10) {
    return true;
  }
  if (major === 10 && build < 10586) {
    return true;
  }
  return false;
}, "isOldWindows");
var clearTerminal = isOldWindows() ? `${eraseScreen}${ESC}0f` : `${eraseScreen}${ESC}3J${ESC}H`;
var enterAlternativeScreen = ESC + "?1049h";
var exitAlternativeScreen = ESC + "?1049l";
var beep = BEL;
var link = /* @__PURE__ */ __name((text, url) => {
  const openLink = wrapOsc(`${OSC}8${SEP}${SEP}${url}${BEL}`);
  const closeLink = wrapOsc(`${OSC}8${SEP}${SEP}${BEL}`);
  return openLink + text + closeLink;
}, "link");
var image = /* @__PURE__ */ __name((data, options = {}) => {
  let returnValue = `${OSC}1337;File=inline=1`;
  if (options.width) {
    returnValue += `;width=${options.width}`;
  }
  if (options.height) {
    returnValue += `;height=${options.height}`;
  }
  if (options.preserveAspectRatio === false) {
    returnValue += ";preserveAspectRatio=0";
  }
  const imageBuffer = Buffer.from(data);
  return wrapOsc(returnValue + `;size=${imageBuffer.byteLength}:` + imageBuffer.toString("base64") + BEL);
}, "image");
var iTerm = {
  setCwd: /* @__PURE__ */ __name((cwd = cwdFunction()) => wrapOsc(`${OSC}50;CurrentDir=${cwd}${BEL}`), "setCwd"),
  annotation(message, options = {}) {
    let returnValue = `${OSC}1337;`;
    const hasX = options.x !== void 0;
    const hasY = options.y !== void 0;
    if ((hasX || hasY) && !(hasX && hasY && options.length !== void 0)) {
      throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
    }
    message = message.replaceAll("|", "");
    returnValue += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
    if (options.length > 0) {
      returnValue += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
    } else {
      returnValue += message;
    }
    return wrapOsc(returnValue + BEL);
  }
};
var ConEmu = {
  setCwd: /* @__PURE__ */ __name((cwd = cwdFunction()) => wrapOsc(`${OSC}9;9;${cwd}${BEL}`), "setCwd")
};
var setCwd = /* @__PURE__ */ __name((cwd = cwdFunction()) => iTerm.setCwd(cwd) + ConEmu.setCwd(cwd), "setCwd");

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/utilities/supportsHyperlinks.js
init_esm();
init_supports_color();

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/has-flag/index.js
init_esm();
import process3 from "process";
function hasFlag(flag, argv = process3.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
__name(hasFlag, "hasFlag");

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/utilities/supportsHyperlinks.js
function parseVersion(versionString = "") {
  if (/^\d{3,4}$/.test(versionString)) {
    const match = /(\d{1,2})(\d{2})/.exec(versionString) ?? [];
    return {
      major: 0,
      minor: Number.parseInt(match[1] ?? "0", 10),
      patch: Number.parseInt(match[2] ?? "0", 10)
    };
  }
  const versions = (versionString ?? "").split(".").map((n) => Number.parseInt(n, 10));
  return {
    major: versions[0] ?? 0,
    minor: versions[1] ?? 0,
    patch: versions[2] ?? 0
  };
}
__name(parseVersion, "parseVersion");
function createSupportsHyperlinks(stream) {
  const { CI, CURSOR_TRACE_ID, FORCE_HYPERLINK, NETLIFY, TEAMCITY_VERSION, TERM_PROGRAM, TERM_PROGRAM_VERSION, VTE_VERSION, TERM } = process.env;
  if (FORCE_HYPERLINK) {
    return !(FORCE_HYPERLINK.length > 0 && Number.parseInt(FORCE_HYPERLINK, 10) === 0);
  }
  if (hasFlag("no-hyperlink") || hasFlag("no-hyperlinks") || hasFlag("hyperlink=false") || hasFlag("hyperlink=never")) {
    return false;
  }
  if (hasFlag("hyperlink=true") || hasFlag("hyperlink=always")) {
    return true;
  }
  if (NETLIFY) {
    return true;
  }
  if (!createSupportsColor(stream)) {
    return false;
  }
  if (stream && !stream.isTTY) {
    return false;
  }
  if ("WT_SESSION" in process.env) {
    return true;
  }
  if (process.platform === "win32") {
    return false;
  }
  if (CI) {
    return false;
  }
  if (TEAMCITY_VERSION) {
    return false;
  }
  if (CURSOR_TRACE_ID) {
    return true;
  }
  if (TERM_PROGRAM) {
    const version = parseVersion(TERM_PROGRAM_VERSION);
    switch (TERM_PROGRAM) {
      case "iTerm.app": {
        if (version.major === 3) {
          return version.minor >= 1;
        }
        return version.major > 3;
      }
      case "WezTerm": {
        return version.major >= 20200620;
      }
      case "vscode": {
        return version.major > 1 || version.major === 1 && version.minor >= 72;
      }
      case "ghostty": {
        return true;
      }
    }
  }
  if (VTE_VERSION) {
    if (VTE_VERSION === "0.50.0") {
      return false;
    }
    const version = parseVersion(VTE_VERSION);
    return version.major > 0 || version.minor >= 50;
  }
  switch (TERM) {
    case "alacritty": {
      return true;
    }
  }
  return false;
}
__name(createSupportsHyperlinks, "createSupportsHyperlinks");
var supportsHyperlinks = {
  /** Whether stdout supports hyperlinks. */
  stdout: createSupportsHyperlinks(process.stdout),
  /** Whether stderr supports hyperlinks. */
  stderr: createSupportsHyperlinks(process.stderr)
};
var supportsHyperlinks_default = supportsHyperlinks;

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/utilities/terminalLink.js
function terminalLink(text, url, { target = "stdout", ...options } = {}) {
  if (!supportsHyperlinks_default[target]) {
    if (options.fallback === false) {
      return text;
    }
    return typeof options.fallback === "function" ? options.fallback(text, url) : `${text} (​${url}​)`;
  }
  return base_exports.link(text, url);
}
__name(terminalLink, "terminalLink");
terminalLink.isSupported = supportsHyperlinks_default.stdout;
terminalLink.stderr = terminalLinkStderr;
function terminalLinkStderr(text, url, options = {}) {
  return terminalLink(text, url, { target: "stderr", ...options });
}
__name(terminalLinkStderr, "terminalLinkStderr");
terminalLinkStderr.isSupported = supportsHyperlinks_default.stderr;

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/utilities/cliOutput.js
var isLinksSupported = terminalLink.isSupported;
function chalkGrey(text) {
  return source_default.hex("#878C99")(text);
}
__name(chalkGrey, "chalkGrey");
function chalkError(text) {
  return source_default.hex("#E11D48")(text);
}
__name(chalkError, "chalkError");
function chalkRun(text) {
  return source_default.hex("#A78BFA")(text);
}
__name(chalkRun, "chalkRun");
function prettyPrintDate(date = /* @__PURE__ */ new Date()) {
  let formattedDate = new Intl.DateTimeFormat("en-US", {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false
  }).format(date);
  formattedDate += "." + ("00" + date.getMilliseconds()).slice(-3);
  return formattedDate;
}
__name(prettyPrintDate, "prettyPrintDate");

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/@trigger.dev/core/dist/esm/v3/machines/index.js
init_esm();
function maxOldSpaceSizeForMachine(machine, overhead = 0.2) {
  return Math.round(machine.memory * 1024 * (1 - overhead));
}
__name(maxOldSpaceSizeForMachine, "maxOldSpaceSizeForMachine");
function maxOldSpaceSizeFlag(machine, overhead = 0.2) {
  return `--max-old-space-size=${maxOldSpaceSizeForMachine(machine, overhead)}`;
}
__name(maxOldSpaceSizeFlag, "maxOldSpaceSizeFlag");
function nodeOptionsWithMaxOldSpaceSize(existingOptions, machine, overhead = 0.2) {
  let options = existingOptions ?? "";
  options = options.replace(/--max-old-space-size=\d+/g, "").trim();
  const flag = maxOldSpaceSizeFlag(machine, overhead);
  return normalizeCommandLineFlags(options ? `${options} ${flag}` : flag);
}
__name(nodeOptionsWithMaxOldSpaceSize, "nodeOptionsWithMaxOldSpaceSize");
function normalizeCommandLineFlags(input) {
  return input.split(/\s+/).filter(Boolean).join(" ");
}
__name(normalizeCommandLineFlags, "normalizeCommandLineFlags");

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/executions/taskRunProcess.js
var TaskRunProcess = class {
  static {
    __name(this, "TaskRunProcess");
  }
  options;
  _ipc;
  _child;
  _childPid;
  _attemptPromises = /* @__PURE__ */ new Map();
  _attemptStatuses = /* @__PURE__ */ new Map();
  _currentExecution;
  _gracefulExitTimeoutElapsed = false;
  _isBeingKilled = false;
  _isBeingCancelled = false;
  _isBeingSuspended = false;
  _isMaxDurationExceeded = false;
  _maxDurationInfo;
  _stderr = [];
  onTaskRunHeartbeat = new import_evt.Evt();
  onExit = new import_evt.Evt();
  onSendDebugLog = new import_evt.Evt();
  onSetSuspendable = new import_evt.Evt();
  _isPreparedForNextRun = false;
  _isPreparedForNextAttempt = false;
  constructor(options) {
    this.options = options;
    this._isPreparedForNextRun = true;
    this._isPreparedForNextAttempt = true;
  }
  get isPreparedForNextRun() {
    return this._isPreparedForNextRun;
  }
  get isPreparedForNextAttempt() {
    return this._isPreparedForNextAttempt;
  }
  unsafeDetachEvtHandlers() {
    this.onExit.detach();
    this.onSendDebugLog.detach();
    this.onSetSuspendable.detach();
    this.onTaskRunHeartbeat.detach();
  }
  async cancel() {
    this._isPreparedForNextRun = false;
    this._isBeingCancelled = true;
    try {
      await this.#cancel();
    } catch (err) {
    }
    await this.#gracefullyTerminate(this.options.gracefulTerminationTimeoutInMs);
  }
  async cleanup(kill = true) {
    this._isPreparedForNextRun = false;
    if (this._isBeingCancelled) {
      return;
    }
    await tryCatch2(this.#flush());
    if (kill) {
      await this.#gracefullyTerminate(this.options.gracefulTerminationTimeoutInMs);
    }
  }
  initialize() {
    const { env: $env, workerManifest: workerManifest2, cwd, machineResources: machine } = this.options;
    const maxOldSpaceSize = nodeOptionsWithMaxOldSpaceSize(void 0, machine);
    const fullEnv = {
      ...$env,
      OTEL_IMPORT_HOOK_INCLUDES: workerManifest2.otelImportHook?.include?.join(","),
      // TODO: this will probably need to use something different for bun (maybe --preload?)
      NODE_OPTIONS: execOptionsForRuntime(workerManifest2.runtime, workerManifest2, maxOldSpaceSize),
      PATH: process.env.PATH,
      TRIGGER_PROCESS_FORK_START_TIME: String(Date.now()),
      TRIGGER_WARM_START: this.options.isWarmStart ? "true" : "false",
      TRIGGERDOTDEV: "1"
    };
    logger.debug(`initializing task run process`, {
      env: fullEnv,
      path: workerManifest2.workerEntryPoint,
      cwd
    });
    this._child = fork(workerManifest2.workerEntryPoint, executorArgs(workerManifest2), {
      stdio: [
        /*stdin*/
        "ignore",
        /*stdout*/
        "pipe",
        /*stderr*/
        "pipe",
        "ipc"
      ],
      cwd,
      env: fullEnv,
      execArgv: ["--trace-uncaught", "--no-warnings=ExperimentalWarning"],
      execPath: execPathForRuntime(workerManifest2.runtime),
      serialization: "json"
    });
    this._childPid = this._child?.pid;
    logger.debug("initialized task run process", {
      path: workerManifest2.workerEntryPoint,
      cwd,
      pid: this._childPid
    });
    this._ipc = new ZodIpcConnection({
      listenSchema: ExecutorToWorkerMessageCatalog,
      emitSchema: WorkerToExecutorMessageCatalog,
      process: this._child,
      handlers: {
        TASK_RUN_COMPLETED: /* @__PURE__ */ __name(async (message) => {
          const { result, execution } = message;
          const key = attemptKey(execution);
          const promiseStatus = this._attemptStatuses.get(key);
          if (promiseStatus !== "PENDING") {
            return;
          }
          this._attemptStatuses.set(key, "RESOLVED");
          const attemptPromise = this._attemptPromises.get(key);
          if (!attemptPromise) {
            return;
          }
          const { resolver } = attemptPromise;
          resolver(result);
        }, "TASK_RUN_COMPLETED"),
        TASK_HEARTBEAT: /* @__PURE__ */ __name(async (message) => {
          this.onTaskRunHeartbeat.post(message.id);
        }, "TASK_HEARTBEAT"),
        UNCAUGHT_EXCEPTION: /* @__PURE__ */ __name(async (message) => {
          logger.debug("uncaught exception in task run process", { ...message });
        }, "UNCAUGHT_EXCEPTION"),
        SEND_DEBUG_LOG: /* @__PURE__ */ __name(async (message) => {
          this.onSendDebugLog.post(message);
        }, "SEND_DEBUG_LOG"),
        SET_SUSPENDABLE: /* @__PURE__ */ __name(async (message) => {
          this.onSetSuspendable.post(message);
        }, "SET_SUSPENDABLE"),
        MAX_DURATION_EXCEEDED: /* @__PURE__ */ __name(async (message) => {
          logger.debug("max duration exceeded, gracefully terminating child process", {
            maxDurationInSeconds: message.maxDurationInSeconds,
            elapsedTimeInSeconds: message.elapsedTimeInSeconds,
            pid: this.pid
          });
          this._isMaxDurationExceeded = true;
          this._maxDurationInfo = {
            maxDurationInSeconds: message.maxDurationInSeconds,
            elapsedTimeInSeconds: message.elapsedTimeInSeconds
          };
          await this.#gracefullyTerminate(this.options.gracefulTerminationTimeoutInMs);
        }, "MAX_DURATION_EXCEEDED")
      }
    });
    this._child.on("exit", this.#handleExit.bind(this));
    this._child.stdout?.on("data", this.#handleLog.bind(this));
    this._child.stderr?.on("data", this.#handleStdErr.bind(this));
    return this;
  }
  async #flush(timeoutInMs = 5e3) {
    logger.debug("flushing task run process", { pid: this.pid });
    await this._ipc?.sendWithAck("FLUSH", { timeoutInMs }, timeoutInMs + 1e3);
  }
  async #cancel(timeoutInMs = 3e4) {
    logger.debug("sending cancel message to task run process", { pid: this.pid, timeoutInMs });
    await this._ipc?.sendWithAck("CANCEL", { timeoutInMs }, timeoutInMs + 1e3);
  }
  async execute(params, isWarmStart) {
    this._isBeingCancelled = false;
    this._isPreparedForNextRun = false;
    this._isPreparedForNextAttempt = false;
    let resolver;
    let rejecter;
    const promise = new Promise((resolve, reject) => {
      resolver = resolve;
      rejecter = reject;
    });
    const key = attemptKey(params.payload.execution);
    this._attemptStatuses.set(key, "PENDING");
    this._attemptPromises.set(key, { resolver, rejecter });
    const { execution, traceContext, metrics } = params.payload;
    this._currentExecution = execution;
    if (this._child?.connected && !this._isBeingKilled && !this._child.killed) {
      logger.debug(`[${(/* @__PURE__ */ new Date()).toISOString()}][${params.payload.execution.run.id}] sending EXECUTE_TASK_RUN message to task run process`, {
        pid: this.pid
      });
      await this._ipc?.send("EXECUTE_TASK_RUN", {
        execution,
        traceContext,
        metadata: this.options.serverWorker,
        metrics,
        env: params.env,
        isWarmStart: isWarmStart ?? this.options.isWarmStart
      });
    }
    const result = await promise;
    this._currentExecution = void 0;
    this._isPreparedForNextAttempt = true;
    return result;
  }
  isExecuting() {
    return this._currentExecution !== void 0;
  }
  waitpointCompleted(waitpoint) {
    if (!this._child?.connected || this._isBeingKilled || this._child.killed) {
      console.error("Child process not connected or being killed, can't send waitpoint completed notification");
      return;
    }
    this._ipc?.send("RESOLVE_WAITPOINT", { waitpoint });
  }
  async #handleExit(code, signal) {
    logger.debug("handling child exit", { code, signal, pid: this.pid });
    for (const [id, status] of this._attemptStatuses.entries()) {
      if (status === "PENDING") {
        logger.debug("found pending attempt", { id });
        this._attemptStatuses.set(id, "REJECTED");
        const attemptPromise = this._attemptPromises.get(id);
        if (!attemptPromise) {
          continue;
        }
        const { rejecter } = attemptPromise;
        if (this._isMaxDurationExceeded) {
          if (!this._maxDurationInfo) {
            rejecter(new UnexpectedExitError(code ?? -1, signal, "MaxDuration flag set but duration info missing"));
            continue;
          }
          rejecter(new MaxDurationExceededError(this._maxDurationInfo.maxDurationInSeconds, this._maxDurationInfo.elapsedTimeInSeconds));
        } else if (this._isBeingCancelled) {
          rejecter(new CancelledProcessError());
        } else if (this._gracefulExitTimeoutElapsed) {
          rejecter(new GracefulExitTimeoutError());
        } else if (this._isBeingKilled) {
          if (this._isBeingSuspended) {
            rejecter(new SuspendedProcessError());
          } else {
            rejecter(new CleanupProcessError());
          }
        } else {
          rejecter(new UnexpectedExitError(code ?? -1, signal, this._stderr.length ? this._stderr.join("\n") : void 0));
        }
      }
    }
    logger.debug("Task run process exited, posting onExit", { code, signal, pid: this.pid });
    this.onExit.post({ code, signal, pid: this.pid });
  }
  #handleLog(data) {
    if (!this._currentExecution) {
      logger.log(`${chalkGrey("○")} ${chalkGrey(prettyPrintDate(/* @__PURE__ */ new Date()))} ${data.toString()}`);
      return;
    }
    const runId = chalkRun(`${this._currentExecution.run.id}.${this._currentExecution.attempt.number}`);
    logger.log(`${chalkGrey("○")} ${chalkGrey(prettyPrintDate(/* @__PURE__ */ new Date()))} ${runId} ${data.toString()}`);
  }
  #handleStdErr(data) {
    if (this._isBeingKilled) {
      return;
    }
    if (!this._currentExecution) {
      logger.log(`${chalkError("○")} ${chalkGrey(prettyPrintDate(/* @__PURE__ */ new Date()))} ${data.toString()}`);
      return;
    }
    const runId = chalkRun(`${this._currentExecution.run.id}.${this._currentExecution.attempt.number}`);
    const errorLine = data.toString();
    logger.log(`${chalkError("○")} ${chalkGrey(prettyPrintDate(/* @__PURE__ */ new Date()))} ${runId} ${errorLine}`);
    if (this._stderr.length > 100) {
      this._stderr.shift();
    }
    this._stderr.push(errorLine);
  }
  async #gracefullyTerminate(timeoutInMs = 1e3) {
    logger.debug("gracefully terminating task run process", { pid: this.pid, timeoutInMs });
    await this.kill("SIGTERM", timeoutInMs);
    if (this._child?.connected) {
      logger.debug("child process is still connected, sending SIGKILL", { pid: this.pid });
      await this.kill("SIGKILL");
    }
  }
  /** This will never throw. */
  async kill(signal, timeoutInMs) {
    logger.debug(`killing task run process`, {
      signal,
      timeoutInMs,
      pid: this.pid
    });
    this._isBeingKilled = true;
    const killTimeout = this.onExit.waitFor(timeoutInMs);
    try {
      this._child?.kill(signal);
    } catch (error2) {
      logger.debug("kill: failed to kill child process", { error: error2 });
    }
    if (!timeoutInMs) {
      return;
    }
    const [error] = await tryCatch2(killTimeout);
    if (error) {
      logger.debug("kill: failed to wait for child process to exit", {
        timeoutInMs,
        signal,
        pid: this.pid
      });
    }
  }
  async suspend({ flush }) {
    this._isBeingSuspended = true;
    if (flush) {
      await tryCatch2(this.#flush());
    }
    await this.kill("SIGKILL");
  }
  get isBeingKilled() {
    return this._isBeingKilled || this._child?.killed;
  }
  get isBeingSuspended() {
    return this._isBeingSuspended;
  }
  get pid() {
    return this._childPid;
  }
  get isHealthy() {
    if (!this._child) {
      return false;
    }
    if (this.isBeingKilled || this.isBeingSuspended) {
      return false;
    }
    return this._child.connected;
  }
  static parseExecuteError(error, dockerMode = true) {
    if (error instanceof CancelledProcessError) {
      return {
        type: "INTERNAL_ERROR",
        code: TaskRunErrorCodes.TASK_RUN_CANCELLED
      };
    }
    if (error instanceof MaxDurationExceededError) {
      return {
        type: "INTERNAL_ERROR",
        code: TaskRunErrorCodes.MAX_DURATION_EXCEEDED,
        message: error.message
      };
    }
    if (error instanceof CleanupProcessError) {
      return {
        type: "INTERNAL_ERROR",
        code: TaskRunErrorCodes.TASK_EXECUTION_ABORTED
      };
    }
    if (error instanceof UnexpectedExitError) {
      return internalErrorFromUnexpectedExit(error, dockerMode);
    }
    if (error instanceof GracefulExitTimeoutError) {
      return {
        type: "INTERNAL_ERROR",
        code: TaskRunErrorCodes.GRACEFUL_EXIT_TIMEOUT
      };
    }
    return {
      type: "INTERNAL_ERROR",
      code: TaskRunErrorCodes.TASK_EXECUTION_FAILED,
      message: String(error)
    };
  }
};
function executorArgs(workerManifest2) {
  return [];
}
__name(executorArgs, "executorArgs");

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/execution.js
import { setTimeout as sleep } from "timers/promises";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/poller.js
init_esm();
var RunExecutionSnapshotPoller = class {
  static {
    __name(this, "RunExecutionSnapshotPoller");
  }
  runFriendlyId;
  snapshotFriendlyId;
  enabled;
  logger;
  onPoll;
  poller;
  lastPollAt = null;
  pollCount = 0;
  constructor(opts) {
    this.enabled = false;
    this.runFriendlyId = opts.runFriendlyId;
    this.snapshotFriendlyId = opts.snapshotFriendlyId;
    this.logger = opts.logger;
    this.onPoll = opts.onPoll;
    const intervalMs = opts.snapshotPollIntervalSeconds * 1e3;
    this.poller = new IntervalService({
      onInterval: /* @__PURE__ */ __name(async () => {
        if (!this.enabled) {
          this.sendDebugLog("poller disabled, skipping snapshot change handler (pre)");
          return;
        }
        this.sendDebugLog("polling for latest snapshot");
        this.lastPollAt = /* @__PURE__ */ new Date();
        this.pollCount++;
        await this.onPoll("poller");
      }, "onInterval"),
      intervalMs,
      leadingEdge: false,
      onError: /* @__PURE__ */ __name(async (error) => {
        this.sendDebugLog("failed to poll for snapshot", {
          error: error instanceof Error ? error.message : String(error)
        });
      }, "onError")
    });
  }
  resetCurrentInterval() {
    this.poller.resetCurrentInterval();
  }
  // The snapshot ID is only used as an indicator of when a poller got stuck
  updateSnapshotId(snapshotFriendlyId) {
    this.snapshotFriendlyId = snapshotFriendlyId;
  }
  updateInterval(intervalMs) {
    this.poller.updateInterval(intervalMs);
  }
  start() {
    if (this.enabled) {
      this.sendDebugLog("already started");
      return this;
    }
    this.sendDebugLog("start");
    this.enabled = true;
    this.poller.start();
    return this;
  }
  stop() {
    if (!this.enabled) {
      this.sendDebugLog("already stopped");
      return;
    }
    this.sendDebugLog("stop");
    this.enabled = false;
    const { isExecuting } = this.poller.stop();
    if (isExecuting) {
      this.sendDebugLog("stopped while executing");
    }
  }
  get metrics() {
    return {
      lastPollAt: this.lastPollAt,
      pollCount: this.pollCount
    };
  }
  sendDebugLog(message, properties) {
    this.logger.sendDebugLog({
      runId: this.runFriendlyId,
      message: `[poller] ${message}`,
      properties: {
        ...properties,
        ...this.metrics,
        snapshotId: this.snapshotFriendlyId,
        pollIntervalMs: this.poller.intervalMs
      }
    });
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/overrides.js
init_esm();
var MetadataClient = class {
  static {
    __name(this, "MetadataClient");
  }
  url;
  constructor(url) {
    this.url = new URL(url);
  }
  async getEnvOverrides() {
    try {
      const response = await fetch(new URL("/env", this.url));
      if (!response.ok) {
        return [new Error(`Status ${response.status} ${response.statusText}`), null];
      }
      return [null, await response.json()];
    } catch (error) {
      return [error instanceof Error ? error : new Error(String(error)), null];
    }
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/execution.js
import { randomBytes } from "node:crypto";

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/snapshot.js
init_esm();
var SnapshotManager = class {
  static {
    __name(this, "SnapshotManager");
  }
  runFriendlyId;
  runnerId;
  logger;
  metadataClient;
  state;
  isSuspendable = false;
  onSnapshotChange;
  onSuspendable;
  changeQueue = [];
  isProcessingQueue = false;
  // Track seen deprecated snapshots to prevent false positives
  seenDeprecatedSnapshotIds = [];
  maxSeenDeprecatedSnapshotIds = 50;
  constructor(opts) {
    this.runFriendlyId = opts.runFriendlyId;
    this.runnerId = opts.runnerId;
    this.logger = opts.logger;
    this.metadataClient = opts.metadataClient;
    this.state = {
      id: opts.initialSnapshotId,
      status: opts.initialStatus
    };
    this.onSnapshotChange = opts.onSnapshotChange;
    this.onSuspendable = opts.onSuspendable;
  }
  get snapshotId() {
    return this.state.id;
  }
  get status() {
    return this.state.status;
  }
  get suspendable() {
    return this.isSuspendable;
  }
  async setSuspendable(suspendable) {
    if (this.isSuspendable === suspendable) {
      this.sendDebugLog(`skipping suspendable update, already ${suspendable}`);
      return;
    }
    this.sendDebugLog(`setting suspendable to ${suspendable}`);
    return this.enqueueSnapshotChange({
      id: crypto.randomUUID(),
      type: "suspendable",
      value: suspendable
    });
  }
  /**
   * Update the snapshot ID and status without invoking any handlers
   *
   * @param snapshotId - The ID of the snapshot to update to
   * @param status - The status to update to
   */
  updateSnapshot(snapshotId, status) {
    if (snapshotId < this.state.id) {
      this.sendDebugLog("skipping update for old snapshot", {
        incomingId: snapshotId,
        currentId: this.state.id
      });
      return;
    }
    this.state = { id: snapshotId, status };
  }
  async handleSnapshotChanges(snapshots) {
    if (!this.statusCheck(snapshots)) {
      return;
    }
    return this.enqueueSnapshotChange({
      id: crypto.randomUUID(),
      type: "snapshot",
      snapshots
    });
  }
  get queueLength() {
    return this.changeQueue.length;
  }
  statusCheck(snapshots) {
    const latestSnapshot = snapshots[snapshots.length - 1];
    if (!latestSnapshot) {
      this.sendDebugLog("skipping status check for empty snapshots", {
        snapshots
      });
      return false;
    }
    const { run, snapshot } = latestSnapshot;
    const statusCheckData = {
      incomingId: snapshot.friendlyId,
      incomingStatus: snapshot.executionStatus,
      currentId: this.state.id,
      currentStatus: this.state.status
    };
    if (run.friendlyId !== this.runFriendlyId) {
      this.sendDebugLog("skipping update for mismatched run ID", {
        statusCheckData
      });
      return false;
    }
    if (snapshot.friendlyId < this.state.id) {
      this.sendDebugLog("skipping update for old snapshot", {
        statusCheckData
      });
      return false;
    }
    if (snapshot.friendlyId === this.state.id) {
      return false;
    }
    return true;
  }
  async enqueueSnapshotChange(change) {
    return new Promise((resolve, reject) => {
      if (change.type === "suspendable") {
        const pendingSuspendable = this.changeQueue.filter((item) => item.change.type === "suspendable");
        for (const item of pendingSuspendable) {
          item.resolve();
        }
        const resolvedIds = new Set(pendingSuspendable.map((item) => item.change.id));
        this.changeQueue = this.changeQueue.filter((item) => !resolvedIds.has(item.change.id));
      }
      this.changeQueue.push({ change, resolve, reject });
      this.changeQueue.sort((a, b2) => {
        if (a.change.type === "suspendable" && b2.change.type === "snapshot") {
          return 1;
        }
        if (a.change.type === "snapshot" && b2.change.type === "suspendable") {
          return -1;
        }
        if (a.change.type === "snapshot" && b2.change.type === "snapshot") {
          const snapshotA = a.change.snapshots[a.change.snapshots.length - 1];
          const snapshotB = b2.change.snapshots[b2.change.snapshots.length - 1];
          if (!snapshotA || !snapshotB) {
            return 0;
          }
          return snapshotA.snapshot.createdAt.getTime() - snapshotB.snapshot.createdAt.getTime();
        }
        return 0;
      });
      this.processQueue().catch((error) => {
        this.sendDebugLog("error processing queue", { error: error.message });
      });
    });
  }
  async processQueue() {
    if (this.isProcessingQueue) {
      return;
    }
    this.isProcessingQueue = true;
    try {
      while (this.queueLength > 0) {
        const item = this.changeQueue.shift();
        if (!item) {
          break;
        }
        const [error] = await tryCatch(this.applyChange(item.change));
        if (error) {
          item.reject(error);
        } else {
          item.resolve();
        }
      }
    } finally {
      const hasMoreItems = this.queueLength > 0;
      this.isProcessingQueue = false;
      if (hasMoreItems) {
        this.processQueue().catch((error) => {
          this.sendDebugLog("error processing queue (finally)", { error: error.message });
        });
      }
    }
  }
  async applyChange(change) {
    switch (change.type) {
      case "snapshot": {
        const { snapshots } = change;
        if (!this.statusCheck(snapshots)) {
          return;
        }
        const latestSnapshot = change.snapshots[change.snapshots.length - 1];
        if (!latestSnapshot) {
          return;
        }
        const previousSnapshots = snapshots.slice(0, -1);
        const deprecatedStatus = ["QUEUED", "SUSPENDED"];
        const deprecatedSnapshots = previousSnapshots.filter((snap) => {
          const isDeprecated = deprecatedStatus.includes(snap.snapshot.executionStatus);
          const previouslySeen = this.seenDeprecatedSnapshotIds.some((s) => s === snap.snapshot.friendlyId);
          return isDeprecated && !previouslySeen;
        });
        let deprecated = false;
        if (deprecatedSnapshots.length > 0) {
          const hasBeenRestored = await this.hasBeenRestored();
          if (hasBeenRestored) {
            deprecated = false;
          } else {
            deprecated = true;
          }
          this.seenDeprecatedSnapshotIds.push(...deprecatedSnapshots.map((s) => s.snapshot.friendlyId));
          if (this.seenDeprecatedSnapshotIds.length > this.maxSeenDeprecatedSnapshotIds) {
            this.seenDeprecatedSnapshotIds = this.seenDeprecatedSnapshotIds.slice(-this.maxSeenDeprecatedSnapshotIds);
          }
        }
        const { snapshot } = latestSnapshot;
        const oldState = { ...this.state };
        this.updateSnapshot(snapshot.friendlyId, snapshot.executionStatus);
        this.sendDebugLog(`status changed to ${snapshot.executionStatus}`, {
          oldId: oldState.id,
          newId: snapshot.friendlyId,
          oldStatus: oldState.status,
          newStatus: snapshot.executionStatus,
          deprecated
        });
        await this.onSnapshotChange(latestSnapshot, deprecated);
        await this.checkSuspendableState();
        break;
      }
      case "suspendable": {
        this.isSuspendable = change.value;
        await this.checkSuspendableState();
        break;
      }
      default: {
        assertExhaustive(change);
      }
    }
  }
  async hasBeenRestored() {
    if (!this.metadataClient) {
      return false;
    }
    const [error, overrides] = await this.metadataClient.getEnvOverrides();
    if (error) {
      return false;
    }
    if (!overrides.TRIGGER_RUNNER_ID) {
      return false;
    }
    if (overrides.TRIGGER_RUNNER_ID === this.runnerId) {
      return false;
    }
    this.runnerId = overrides.TRIGGER_RUNNER_ID;
    return true;
  }
  async checkSuspendableState() {
    if (this.isSuspendable && (this.state.status === "EXECUTING_WITH_WAITPOINTS" || this.state.status === "QUEUED_EXECUTING")) {
      await this.onSuspendable(this.state);
    }
  }
  stop() {
    this.sendDebugLog("stop");
    for (const item of this.changeQueue) {
      item.reject(new Error("SnapshotManager stopped"));
    }
    this.changeQueue = [];
  }
  sendDebugLog(message, properties) {
    this.logger.sendDebugLog({
      runId: this.runFriendlyId,
      message: `[snapshot] ${message}`,
      properties: {
        ...properties,
        snapshotId: this.state.id,
        status: this.state.status,
        suspendable: this.isSuspendable,
        queueLength: this.queueLength,
        isProcessingQueue: this.isProcessingQueue
      }
    });
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/notifier.js
init_esm();
var RunNotifier = class {
  static {
    __name(this, "RunNotifier");
  }
  runFriendlyId;
  socket;
  onNotify;
  logger;
  lastNotificationAt = null;
  notificationCount = 0;
  lastInvalidNotificationAt = null;
  invalidNotificationCount = 0;
  constructor(opts) {
    this.runFriendlyId = opts.runFriendlyId;
    this.socket = opts.supervisorSocket;
    this.onNotify = opts.onNotify;
    this.logger = opts.logger;
  }
  start() {
    this.sendDebugLog("start");
    this.socket.on("run:notify", async ({ version, run }) => {
      const notificationId = Math.random().toString(36).substring(2, 15);
      const notification = {
        id: notificationId,
        runId: run.friendlyId,
        version
      };
      if (run.friendlyId !== this.runFriendlyId) {
        this.sendDebugLog("run:notify received invalid notification", { notification });
        this.invalidNotificationCount++;
        this.lastInvalidNotificationAt = /* @__PURE__ */ new Date();
        return;
      }
      this.sendDebugLog("run:notify received by runner", { notification });
      this.notificationCount++;
      this.lastNotificationAt = /* @__PURE__ */ new Date();
      await this.onNotify(`notifier:${notificationId}`);
    });
    return this;
  }
  stop() {
    this.sendDebugLog("stop");
    this.socket.removeAllListeners("run:notify");
  }
  get metrics() {
    return {
      lastNotificationAt: this.lastNotificationAt,
      notificationCount: this.notificationCount,
      lastInvalidNotificationAt: this.lastInvalidNotificationAt,
      invalidNotificationCount: this.invalidNotificationCount
    };
  }
  sendDebugLog(message, properties) {
    this.logger.sendDebugLog({
      runId: this.runFriendlyId,
      message: `[notifier] ${message}`,
      properties: {
        ...properties,
        ...this.metrics
      }
    });
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/execution.js
var ExecutionAbortError = class extends Error {
  static {
    __name(this, "ExecutionAbortError");
  }
  constructor(message) {
    super(message);
    this.name = "ExecutionAbortError";
  }
};
var RunExecution = class {
  static {
    __name(this, "RunExecution");
  }
  id;
  executionAbortController;
  _runFriendlyId;
  currentAttemptNumber;
  currentTaskRunEnv;
  snapshotManager;
  dequeuedAt;
  podScheduledAt;
  workerManifest;
  env;
  httpClient;
  logger;
  restoreCount;
  taskRunProcess;
  snapshotPoller;
  lastHeartbeat;
  isShuttingDown = false;
  shutdownReason;
  isCompletingRun = false;
  ignoreSnapshotChanges = false;
  supervisorSocket;
  notifier;
  metadataClient;
  taskRunProcessProvider;
  constructor(opts) {
    this.id = randomBytes(4).toString("hex");
    this.workerManifest = opts.workerManifest;
    this.env = opts.env;
    this.httpClient = opts.httpClient;
    this.logger = opts.logger;
    this.supervisorSocket = opts.supervisorSocket;
    this.taskRunProcessProvider = opts.taskRunProcessProvider;
    this.restoreCount = 0;
    this.executionAbortController = new AbortController();
    if (this.env.TRIGGER_METADATA_URL) {
      this.metadataClient = new MetadataClient(this.env.TRIGGER_METADATA_URL);
    }
  }
  /**
   * Cancels the current execution.
   */
  async cancel() {
    if (this.isShuttingDown) {
      throw new Error("cancel called after execution shut down");
    }
    this.sendDebugLog("cancelling attempt", { runId: this.runFriendlyId });
    await this.taskRunProcess?.cancel();
  }
  /**
   * Kills the current execution.
   */
  async kill({ exitExecution = true } = {}) {
    if (this.taskRunProcess) {
      await this.taskRunProcessProvider.handleProcessAbort(this.taskRunProcess);
    }
    if (exitExecution) {
      this.shutdownExecution("kill");
    }
  }
  async shutdown() {
    if (this.taskRunProcess) {
      await this.taskRunProcessProvider.handleProcessAbort(this.taskRunProcess);
    }
    this.shutdownExecution("shutdown");
  }
  /**
   * Prepares the execution with task run environment variables.
   * This should be called before executing, typically after a successful run to prepare for the next one.
   */
  async prepareForExecution(opts) {
    if (this.isShuttingDown) {
      throw new Error("prepareForExecution called after execution shut down");
    }
    if (this.taskRunProcess) {
      throw new Error("prepareForExecution called after process was already created");
    }
    this.currentTaskRunEnv = opts.taskRunEnv;
    this.taskRunProcess = await this.taskRunProcessProvider.getProcess({
      taskRunEnv: opts.taskRunEnv,
      isWarmStart: true
    });
  }
  attachTaskRunProcessHandlers(taskRunProcess) {
    taskRunProcess.unsafeDetachEvtHandlers();
    taskRunProcess.onTaskRunHeartbeat.attach(async (runId) => {
      if (!this.runFriendlyId) {
        this.sendDebugLog("onTaskRunHeartbeat: missing run ID", { heartbeatRunId: runId });
        return;
      }
      if (runId !== this.runFriendlyId) {
        this.sendDebugLog("onTaskRunHeartbeat: mismatched run ID", {
          heartbeatRunId: runId,
          expectedRunId: this.runFriendlyId
        });
        return;
      }
      const [error] = await tryCatch(this.onHeartbeat());
      if (error) {
        this.sendDebugLog("onTaskRunHeartbeat: failed", { error: error.message });
      }
    });
    taskRunProcess.onSendDebugLog.attach(async (debugLog) => {
      this.sendRuntimeDebugLog(debugLog.message, debugLog.properties);
    });
    taskRunProcess.onSetSuspendable.attach(async ({ suspendable }) => {
      this.suspendable = suspendable;
    });
  }
  /**
   * Returns true if no run has been started yet and we're prepared for the next run.
   */
  get canExecute() {
    if (this.taskRunProcessProvider.hasPersistentProcess) {
      return true;
    }
    if (this._runFriendlyId) {
      return false;
    }
    return !!this.currentTaskRunEnv;
  }
  /**
   * Called by the RunController when it receives a websocket notification
   * or when the snapshot poller detects a change.
   *
   * This is the main entry point for snapshot changes, but processing is deferred to the snapshot manager.
   */
  async enqueueSnapshotChangesAndWait(snapshots) {
    if (this.isShuttingDown) {
      this.sendDebugLog("enqueueSnapshotChangeAndWait: shutting down, skipping");
      return;
    }
    if (!this.snapshotManager) {
      this.sendDebugLog("enqueueSnapshotChangeAndWait: missing snapshot manager");
      return;
    }
    await this.snapshotManager.handleSnapshotChanges(snapshots);
  }
  async processSnapshotChange(runData, deprecated) {
    const { run, snapshot, completedWaitpoints } = runData;
    const snapshotMetadata = {
      incomingSnapshotId: snapshot.friendlyId,
      completedWaitpoints: completedWaitpoints.length
    };
    if (this.ignoreSnapshotChanges) {
      this.sendDebugLog("processSnapshotChange: ignoring snapshot change", {
        incomingSnapshotId: snapshot.friendlyId,
        completedWaitpoints: completedWaitpoints.length,
        currentAttemptNumber: this.currentAttemptNumber,
        newAttemptNumber: run.attemptNumber
      });
      return;
    }
    if (!this.snapshotManager) {
      this.sendDebugLog("handleSnapshotChange: missing snapshot manager", snapshotMetadata);
      return;
    }
    if (this.currentAttemptNumber && this.currentAttemptNumber !== run.attemptNumber) {
      this.sendDebugLog("error: attempt number mismatch", snapshotMetadata);
      await this.exitTaskRunProcessWithoutFailingRun({
        flush: false,
        reason: "attempt number mismatch"
      });
      return;
    }
    this.snapshotPoller?.updateSnapshotId(snapshot.friendlyId);
    this.snapshotPoller?.resetCurrentInterval();
    if (deprecated) {
      this.sendDebugLog("run execution is deprecated", { incomingSnapshot: snapshot });
      await this.exitTaskRunProcessWithoutFailingRun({
        flush: false,
        reason: "deprecated execution"
      });
      return;
    }
    switch (snapshot.executionStatus) {
      case "PENDING_CANCEL": {
        this.sendDebugLog("run was cancelled", snapshotMetadata);
        const [error] = await tryCatch(this.cancel());
        if (error) {
          this.sendDebugLog("snapshot change: failed to cancel attempt", {
            ...snapshotMetadata,
            error: error.message
          });
        }
        this.abortExecution();
        return;
      }
      case "QUEUED": {
        this.sendDebugLog("run was re-queued", snapshotMetadata);
        await this.exitTaskRunProcessWithoutFailingRun({ flush: true, reason: "re-queued" });
        return;
      }
      case "FINISHED": {
        this.sendDebugLog("run is finished", snapshotMetadata);
        if (this.isCompletingRun) {
          this.sendDebugLog("run is finished but we're completing it, skipping", snapshotMetadata);
          return;
        }
        await this.exitTaskRunProcessWithoutFailingRun({ flush: true, reason: "already-finished" });
        return;
      }
      case "QUEUED_EXECUTING":
      case "EXECUTING_WITH_WAITPOINTS": {
        this.sendDebugLog("run is executing with waitpoints", snapshotMetadata);
        return;
      }
      case "SUSPENDED": {
        this.sendDebugLog("run was suspended", snapshotMetadata);
        await this.exitTaskRunProcessWithoutFailingRun({ flush: false, reason: "suspended" });
        return;
      }
      case "PENDING_EXECUTING": {
        this.sendDebugLog("run is pending execution", snapshotMetadata);
        if (completedWaitpoints.length === 0) {
          this.sendDebugLog("no waitpoints to complete, nothing to do", snapshotMetadata);
          return;
        }
        const [error] = await tryCatch(this.restore());
        if (error) {
          this.sendDebugLog("failed to restore execution", {
            ...snapshotMetadata,
            error: error.message
          });
          this.abortExecution();
          return;
        }
        return;
      }
      case "EXECUTING": {
        if (completedWaitpoints.length === 0) {
          this.sendDebugLog("run is executing without completed waitpoints", snapshotMetadata);
          return;
        }
        this.sendDebugLog("run is executing with completed waitpoints", snapshotMetadata);
        if (!this.taskRunProcess) {
          this.sendDebugLog("no task run process, ignoring completed waitpoints", snapshotMetadata);
          this.abortExecution();
          return;
        }
        for (const waitpoint of completedWaitpoints) {
          this.taskRunProcess.waitpointCompleted(waitpoint);
        }
        return;
      }
      case "RUN_CREATED": {
        this.sendDebugLog("aborting execution: invalid status change: RUN_CREATED", snapshotMetadata);
        this.abortExecution();
        return;
      }
      default: {
        assertExhaustive(snapshot.executionStatus);
      }
    }
  }
  async startAttempt({ isWarmStart }) {
    if (!this.runFriendlyId || !this.snapshotManager) {
      throw new Error("Cannot start attempt: missing run or snapshot manager");
    }
    this.isCompletingRun = false;
    this.sendDebugLog("starting attempt", { isWarmStart: String(isWarmStart) });
    const attemptStartedAt = Date.now();
    if (this.executionAbortController.signal.aborted) {
      throw new ExecutionAbortError("Execution aborted before start");
    }
    const start = await this.httpClient.startRunAttempt(this.runFriendlyId, this.snapshotManager.snapshotId, { isWarmStart });
    if (this.executionAbortController.signal.aborted) {
      throw new ExecutionAbortError("Execution aborted after start");
    }
    if (!start.success) {
      throw new Error(`Start API call failed: ${start.error}`);
    }
    this.snapshotManager.updateSnapshot(start.data.snapshot.friendlyId, start.data.snapshot.executionStatus);
    const attemptNumber = start.data.run.attemptNumber;
    if (attemptNumber && attemptNumber > 0) {
      this.currentAttemptNumber = attemptNumber;
    } else {
      this.sendDebugLog("error: invalid attempt number returned from start attempt", {
        attemptNumber: String(attemptNumber)
      });
    }
    const metrics = this.measureExecutionMetrics({
      attemptCreatedAt: attemptStartedAt,
      dequeuedAt: this.dequeuedAt?.getTime(),
      podScheduledAt: this.podScheduledAt?.getTime()
    });
    this.sendDebugLog("started attempt", { start: start.data });
    return { ...start.data, metrics };
  }
  /**
   * Executes the run. This will return when the execution is complete and we should warm start.
   * When this returns, the child process will have been cleaned up.
   */
  async execute(runOpts) {
    if (this.isShuttingDown) {
      throw new Error("execute called after execution shut down");
    }
    this.runFriendlyId = runOpts.runFriendlyId;
    this.snapshotManager = new SnapshotManager({
      runFriendlyId: runOpts.runFriendlyId,
      runnerId: this.env.TRIGGER_RUNNER_ID,
      initialSnapshotId: runOpts.snapshotFriendlyId,
      // We're just guessing here, but "PENDING_EXECUTING" is probably fine
      initialStatus: "PENDING_EXECUTING",
      logger: this.logger,
      metadataClient: this.metadataClient,
      onSnapshotChange: this.processSnapshotChange.bind(this),
      onSuspendable: this.handleSuspendable.bind(this)
    });
    this.dequeuedAt = runOpts.dequeuedAt;
    this.podScheduledAt = runOpts.podScheduledAt;
    this.snapshotPoller = new RunExecutionSnapshotPoller({
      runFriendlyId: this.runFriendlyId,
      snapshotFriendlyId: this.snapshotManager.snapshotId,
      logger: this.logger,
      snapshotPollIntervalSeconds: this.env.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS,
      onPoll: this.fetchAndProcessSnapshotChanges.bind(this)
    }).start();
    this.notifier = new RunNotifier({
      runFriendlyId: this.runFriendlyId,
      supervisorSocket: this.supervisorSocket,
      onNotify: this.fetchAndProcessSnapshotChanges.bind(this),
      logger: this.logger
    }).start();
    const [startError, start] = await tryCatch(this.startAttempt({ isWarmStart: runOpts.isWarmStart }));
    if (startError) {
      this.sendDebugLog("failed to start attempt", { error: startError.message });
      this.shutdownExecution("failed to start attempt");
      return;
    }
    const [executeError] = await tryCatch(this.executeRunWrapper({ ...start, isWarmStart: runOpts.isWarmStart }));
    if (executeError) {
      this.sendDebugLog("failed to execute run", { error: executeError.message });
      this.shutdownExecution("failed to execute run");
      return;
    }
    this.shutdownExecution("execute call finished");
  }
  async executeRunWrapper({ run, snapshot, envVars, execution, metrics, isWarmStart, isImmediateRetry }) {
    this.currentTaskRunEnv = envVars;
    const [executeError] = await tryCatch(this.executeRun({
      run,
      snapshot,
      envVars,
      execution,
      metrics,
      isWarmStart,
      isImmediateRetry
    }));
    if (!executeError) {
      return;
    }
    if (executeError instanceof SuspendedProcessError) {
      this.sendDebugLog("execution was suspended", {
        run: run.friendlyId,
        snapshot: snapshot.friendlyId,
        error: executeError.message
      });
      return;
    }
    if (executeError instanceof ExecutionAbortError) {
      this.sendDebugLog("execution was aborted", {
        run: run.friendlyId,
        snapshot: snapshot.friendlyId,
        error: executeError.message
      });
      return;
    }
    this.sendDebugLog("error while executing attempt", {
      error: executeError.message,
      runId: run.friendlyId,
      snapshotId: snapshot.friendlyId
    });
    const completion = {
      id: execution.run.id,
      ok: false,
      retry: void 0,
      error: TaskRunProcess.parseExecuteError(executeError)
    };
    const [completeError] = await tryCatch(this.complete({ completion }));
    if (completeError) {
      this.sendDebugLog("failed to complete run", { error: completeError.message });
    }
  }
  async executeRun({ run, snapshot, envVars, execution, metrics, isWarmStart, isImmediateRetry }) {
    if (isImmediateRetry) {
      await this.taskRunProcessProvider.handleImmediateRetry();
    }
    const taskRunEnv = this.currentTaskRunEnv ?? envVars;
    if (!this.taskRunProcess || this.taskRunProcess.isBeingKilled) {
      this.sendDebugLog("getting new task run process", { runId: execution.run.id });
      this.taskRunProcess = await this.taskRunProcessProvider.getProcess({
        taskRunEnv: { ...taskRunEnv, TRIGGER_PROJECT_REF: execution.project.ref },
        isWarmStart
      });
    } else {
      this.sendDebugLog("using prepared task run process", { runId: execution.run.id });
    }
    this.attachTaskRunProcessHandlers(this.taskRunProcess);
    this.sendDebugLog("executing task run process", { runId: execution.run.id });
    const abortHandler = /* @__PURE__ */ __name(async () => {
      this.sendDebugLog("execution aborted during task run, cleaning up process", {
        runId: execution.run.id
      });
      if (this.taskRunProcess) {
        await this.taskRunProcessProvider.handleProcessAbort(this.taskRunProcess);
      }
    }, "abortHandler");
    this.executionAbortController.signal.addEventListener("abort", abortHandler);
    const completion = await this.taskRunProcess.execute({
      payload: {
        execution,
        traceContext: execution.run.traceContext ?? {},
        metrics
      },
      messageId: run.friendlyId,
      env: envVars
    }, isWarmStart);
    this.executionAbortController.signal.removeEventListener("abort", abortHandler);
    this.sendDebugLog("completed run attempt", { attemptSuccess: completion.ok });
    const [returnError] = await tryCatch(this.taskRunProcessProvider.returnProcess(this.taskRunProcess));
    if (returnError) {
      this.sendDebugLog("failed to return task run process, submitting completion anyway", {
        error: returnError.message
      });
    }
    const [completionError] = await tryCatch(this.complete({ completion }));
    if (completionError) {
      this.sendDebugLog("failed to complete run", { error: completionError.message });
    }
  }
  async complete({ completion }) {
    if (!this.runFriendlyId || !this.snapshotManager) {
      throw new Error("cannot complete run: missing run or snapshot manager");
    }
    this.isCompletingRun = true;
    const completionResult = await this.httpClient.completeRunAttempt(this.runFriendlyId, this.snapshotManager.snapshotId, { completion });
    if (!completionResult.success) {
      throw new Error(`failed to submit completion: ${completionResult.error}`);
    }
    await this.handleCompletionResult({
      completion,
      result: completionResult.data.result
    });
  }
  async handleCompletionResult({ completion, result }) {
    this.sendDebugLog(`completion result: ${result.attemptStatus}`, {
      attemptSuccess: completion.ok,
      attemptStatus: result.attemptStatus,
      snapshotId: result.snapshot.friendlyId,
      runId: result.run.friendlyId
    });
    const snapshotStatus = this.convertAttemptStatusToSnapshotStatus(result.attemptStatus);
    this.updateSnapshotAfterCompletion(result.snapshot.friendlyId, snapshotStatus);
    const { attemptStatus } = result;
    switch (attemptStatus) {
      case "RUN_FINISHED":
      case "RUN_PENDING_CANCEL":
      case "RETRY_QUEUED": {
        return;
      }
      case "RETRY_IMMEDIATELY": {
        if (attemptStatus !== "RETRY_IMMEDIATELY") {
          return;
        }
        if (completion.ok) {
          throw new Error("Should retry but completion OK.");
        }
        if (!completion.retry) {
          throw new Error("Should retry but missing retry params.");
        }
        await this.retryImmediately({ retryOpts: completion.retry });
        return;
      }
      default: {
        assertExhaustive(attemptStatus);
      }
    }
  }
  updateSnapshotAfterCompletion(snapshotId, status) {
    this.snapshotManager?.updateSnapshot(snapshotId, status);
    this.snapshotPoller?.updateSnapshotId(snapshotId);
  }
  convertAttemptStatusToSnapshotStatus(attemptStatus) {
    switch (attemptStatus) {
      case "RUN_FINISHED":
        return "FINISHED";
      case "RUN_PENDING_CANCEL":
        return "PENDING_CANCEL";
      case "RETRY_QUEUED":
        return "QUEUED";
      case "RETRY_IMMEDIATELY":
        return "EXECUTING";
      default:
        assertExhaustive(attemptStatus);
    }
  }
  measureExecutionMetrics({ attemptCreatedAt, dequeuedAt, podScheduledAt }) {
    const metrics = [
      {
        name: "start",
        event: "create_attempt",
        timestamp: attemptCreatedAt,
        duration: Date.now() - attemptCreatedAt
      }
    ];
    if (dequeuedAt) {
      metrics.push({
        name: "start",
        event: "dequeue",
        timestamp: dequeuedAt,
        duration: 0
      });
    }
    if (podScheduledAt) {
      metrics.push({
        name: "start",
        event: "pod_scheduled",
        timestamp: podScheduledAt,
        duration: 0
      });
    }
    return metrics;
  }
  async retryImmediately({ retryOpts }) {
    this.sendDebugLog("retrying run immediately", {
      timestamp: retryOpts.timestamp,
      delay: retryOpts.delay
    });
    const delay = retryOpts.timestamp - Date.now();
    if (delay > 0) {
      await sleep(delay);
    }
    const [startError, start] = await tryCatch(this.enableIgnoreSnapshotChanges(() => this.startAttempt({ isWarmStart: true })));
    if (startError) {
      this.sendDebugLog("failed to start attempt for retry", { error: startError.message });
      this.shutdownExecution("retryImmediately: failed to start attempt");
      return;
    }
    const [executeError] = await tryCatch(this.executeRunWrapper({ ...start, isWarmStart: true, isImmediateRetry: true }));
    if (executeError) {
      this.sendDebugLog("failed to execute run for retry", { error: executeError.message });
      this.shutdownExecution("retryImmediately: failed to execute run");
      return;
    }
  }
  async enableIgnoreSnapshotChanges(fn) {
    this.ignoreSnapshotChanges = true;
    try {
      return await fn();
    } finally {
      this.ignoreSnapshotChanges = false;
    }
  }
  /**
   * Restores a suspended execution from PENDING_EXECUTING
   */
  async restore() {
    this.sendDebugLog("restoring execution");
    if (!this.runFriendlyId || !this.snapshotManager) {
      throw new Error("Cannot restore: missing run or snapshot manager");
    }
    await sleep(100);
    await this.processEnvOverrides("restore");
    const continuationResult = await this.httpClient.continueRunExecution(this.runFriendlyId, this.snapshotManager.snapshotId);
    if (!continuationResult.success) {
      if (continuationResult.isConnectionError) {
        this.sendDebugLog("restore: connection error detected, refreshing metadata");
        await this.processEnvOverrides("restore connection error");
        const retryResult = await this.httpClient.continueRunExecution(this.runFriendlyId, this.snapshotManager.snapshotId);
        if (!retryResult.success) {
          throw new Error(retryResult.error);
        }
      } else {
        throw new Error(continuationResult.error);
      }
    }
    this.restoreCount++;
  }
  async exitTaskRunProcessWithoutFailingRun({ flush, reason }) {
    await this.taskRunProcessProvider.suspendProcess(flush, this.taskRunProcess);
    this.shutdownExecution(`exitTaskRunProcessWithoutFailingRun: ${reason}`);
  }
  /**
   * Processes env overrides from the metadata service. Generally called when we're resuming from a suspended state.
   */
  async processEnvOverrides(reason, shouldPollForSnapshotChanges) {
    if (!this.metadataClient) {
      return null;
    }
    const previousRunnerId = this.env.TRIGGER_RUNNER_ID;
    const previousSupervisorUrl = this.env.TRIGGER_SUPERVISOR_API_URL;
    const [error, overrides] = await this.metadataClient.getEnvOverrides();
    if (error) {
      this.sendDebugLog("[override] failed to fetch", {
        reason,
        error: error.message
      });
      return null;
    }
    if (overrides.TRIGGER_RUN_ID && overrides.TRIGGER_RUN_ID !== this.runFriendlyId) {
      this.sendDebugLog("[override] run ID mismatch, ignoring overrides", {
        reason,
        currentRunId: this.runFriendlyId,
        incomingRunId: overrides.TRIGGER_RUN_ID
      });
      return null;
    }
    this.sendDebugLog(`[override] processing: ${reason}`, {
      overrides,
      currentEnv: this.env.raw
    });
    this.env.override(overrides);
    const newRunnerId = this.env.TRIGGER_RUNNER_ID;
    const runnerIdChanged = previousRunnerId !== newRunnerId;
    const newSupervisorUrl = this.env.TRIGGER_SUPERVISOR_API_URL;
    const supervisorChanged = previousSupervisorUrl !== newSupervisorUrl;
    if (overrides.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS) {
      this.snapshotPoller?.updateInterval(this.env.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS * 1e3);
    }
    if (overrides.TRIGGER_SUPERVISOR_API_PROTOCOL || overrides.TRIGGER_SUPERVISOR_API_DOMAIN || overrides.TRIGGER_SUPERVISOR_API_PORT) {
      this.httpClient.updateApiUrl(this.env.TRIGGER_SUPERVISOR_API_URL);
    }
    if (overrides.TRIGGER_RUNNER_ID) {
      this.httpClient.updateRunnerId(this.env.TRIGGER_RUNNER_ID);
    }
    if (shouldPollForSnapshotChanges) {
      this.sendDebugLog("[override] polling for snapshot changes", { reason });
      this.fetchAndProcessSnapshotChanges("restore").catch(() => {
      });
    }
    return {
      overrides,
      runnerIdChanged,
      supervisorChanged
    };
  }
  async onHeartbeat() {
    if (!this.runFriendlyId) {
      this.sendDebugLog("heartbeat: missing run ID");
      return;
    }
    if (!this.snapshotManager) {
      this.sendDebugLog("heartbeat: missing snapshot manager");
      return;
    }
    this.sendDebugLog("heartbeat");
    const response = await this.httpClient.heartbeatRun(this.runFriendlyId, this.snapshotManager.snapshotId);
    if (!response.success) {
      this.sendDebugLog("heartbeat: failed", { error: response.error });
      if (response.isConnectionError) {
        this.sendDebugLog("heartbeat: connection error detected, refreshing metadata");
        await this.processEnvOverrides("heartbeat connection error");
      }
    }
    this.lastHeartbeat = /* @__PURE__ */ new Date();
  }
  sendDebugLog(message, properties, runIdOverride) {
    this.logger.sendDebugLog({
      runId: runIdOverride ?? this.runFriendlyId,
      message: `[execution] ${message}`,
      properties: {
        ...properties,
        runId: this.runFriendlyId,
        snapshotId: this.currentSnapshotFriendlyId,
        executionId: this.id,
        executionRestoreCount: this.restoreCount,
        lastHeartbeat: this.lastHeartbeat?.toISOString()
      }
    });
  }
  sendRuntimeDebugLog(message, properties, runIdOverride) {
    this.logger.sendDebugLog({
      runId: runIdOverride ?? this.runFriendlyId,
      message: `[runtime] ${message}`,
      print: false,
      properties: {
        ...properties,
        runId: this.runFriendlyId,
        snapshotId: this.currentSnapshotFriendlyId,
        executionId: this.id,
        executionRestoreCount: this.restoreCount,
        lastHeartbeat: this.lastHeartbeat?.toISOString()
      }
    });
  }
  set suspendable(suspendable) {
    this.snapshotManager?.setSuspendable(suspendable).catch((error) => {
      this.sendDebugLog("failed to set suspendable", { error: error.message });
    });
  }
  // Ensure we can only set this once
  set runFriendlyId(id) {
    if (this._runFriendlyId) {
      throw new Error("Run ID already set");
    }
    this._runFriendlyId = id;
  }
  get runFriendlyId() {
    return this._runFriendlyId;
  }
  get currentSnapshotFriendlyId() {
    return this.snapshotManager?.snapshotId;
  }
  get taskRunEnv() {
    return this.currentTaskRunEnv;
  }
  get metrics() {
    return {
      execution: {
        restoreCount: this.restoreCount,
        lastHeartbeat: this.lastHeartbeat
      },
      poller: this.snapshotPoller?.metrics,
      notifier: this.notifier?.metrics
    };
  }
  get isAborted() {
    return this.executionAbortController.signal.aborted;
  }
  abortExecution() {
    if (this.isAborted) {
      this.sendDebugLog("execution already aborted");
      return;
    }
    this.executionAbortController.abort();
    this.shutdownExecution("abortExecution");
  }
  shutdownExecution(reason) {
    if (this.isShuttingDown) {
      this.sendDebugLog(`[shutdown] ${reason} (already shutting down)`, {
        firstShutdownReason: this.shutdownReason
      });
      return;
    }
    this.sendDebugLog(`[shutdown] ${reason}`);
    this.isShuttingDown = true;
    this.shutdownReason = reason;
    this.snapshotPoller?.stop();
    this.snapshotManager?.stop();
    this.notifier?.stop();
    this.taskRunProcess?.unsafeDetachEvtHandlers();
  }
  async handleSuspendable(suspendableSnapshot) {
    this.sendDebugLog("handleSuspendable", { suspendableSnapshot });
    if (!this.snapshotManager) {
      this.sendDebugLog("handleSuspendable: missing snapshot manager", { suspendableSnapshot });
      return;
    }
    if (suspendableSnapshot.id !== this.currentSnapshotFriendlyId) {
      this.sendDebugLog("snapshot changed before cleanup, abort", {
        suspendableSnapshot,
        currentSnapshotId: this.currentSnapshotFriendlyId
      });
      this.abortExecution();
      return;
    }
    const [error] = await tryCatch(this.taskRunProcess?.cleanup(false));
    if (error) {
      this.sendDebugLog("failed to cleanup task run process, carrying on", {
        suspendableSnapshot,
        error: error.message
      });
    }
    if (suspendableSnapshot.id !== this.currentSnapshotFriendlyId) {
      this.sendDebugLog("snapshot changed after cleanup, abort", {
        suspendableSnapshot,
        currentSnapshotId: this.currentSnapshotFriendlyId
      });
      this.abortExecution();
      return;
    }
    if (!this.runFriendlyId) {
      this.sendDebugLog("missing run ID for suspension, abort", { suspendableSnapshot });
      this.abortExecution();
      return;
    }
    const suspendResult = await this.httpClient.suspendRun(this.runFriendlyId, suspendableSnapshot.id);
    if (!suspendResult.success) {
      this.sendDebugLog("suspension request failed, staying alive 🎶", {
        suspendableSnapshot,
        error: suspendResult.error
      });
      return;
    }
    if (!suspendResult.data.ok) {
      this.sendDebugLog("suspension request returned error, staying alive 🎶", {
        suspendableSnapshot,
        error: suspendResult.data.error
      });
      return;
    }
    this.sendDebugLog("suspending, any day now 🚬", { suspendableSnapshot });
  }
  /**
   * Fetches the latest execution data and enqueues snapshot changes. Used by both poller and notification handlers.
   * @param source string - where this call originated (e.g. 'poller', 'notification')
   */
  async fetchAndProcessSnapshotChanges(source) {
    if (!this.runFriendlyId) {
      this.sendDebugLog(`fetchAndProcessSnapshotChanges: missing runFriendlyId`, { source });
      return;
    }
    const sinceSnapshotId = this.currentSnapshotFriendlyId;
    if (!sinceSnapshotId) {
      this.sendDebugLog(`fetchAndProcessSnapshotChanges: missing sinceSnapshotId`, { source });
      return;
    }
    const response = await this.httpClient.getSnapshotsSince(this.runFriendlyId, sinceSnapshotId);
    if (!response.success) {
      this.sendDebugLog(`fetchAndProcessSnapshotChanges: failed to get snapshots since`, {
        source,
        error: response.error
      });
      if (response.isConnectionError) {
        this.sendDebugLog("fetchAndProcessSnapshotChanges: connection error detected, refreshing metadata");
      }
      await this.processEnvOverrides("snapshots since error");
      return;
    }
    const { snapshots } = response.data;
    if (!snapshots.length) {
      return;
    }
    const [error] = await tryCatch(this.enqueueSnapshotChangesAndWait(snapshots));
    if (error) {
      this.sendDebugLog(`fetchAndProcessSnapshotChanges: failed to enqueue and process snapshot change`, {
        source,
        error: error.message
      });
      return;
    }
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/taskRunProcessProvider.js
init_esm();
var TaskRunProcessProvider = class {
  static {
    __name(this, "TaskRunProcessProvider");
  }
  workerManifest;
  env;
  logger;
  processKeepAliveEnabled;
  processKeepAliveMaxExecutionCount;
  // Process keep-alive state
  persistentProcess = null;
  executionCount = 0;
  constructor(opts) {
    this.workerManifest = opts.workerManifest;
    this.env = opts.env;
    this.logger = opts.logger;
    this.processKeepAliveEnabled = opts.processKeepAliveEnabled;
    this.processKeepAliveMaxExecutionCount = opts.processKeepAliveMaxExecutionCount;
  }
  get hasPersistentProcess() {
    return !!this.persistentProcess;
  }
  async handleImmediateRetry() {
    if (!this.processKeepAliveEnabled) {
      if (this.persistentProcess) {
        if (!this.persistentProcess.isPreparedForNextAttempt) {
          this.sendDebugLog("existing task run process not prepared for retry, will get fresh process");
          await this.persistentProcess.kill("SIGKILL");
          this.persistentProcess = null;
        }
      }
    }
  }
  /**
   * Gets a TaskRunProcess, either by reusing an existing one or creating a new one
   */
  async getProcess(opts) {
    this.sendDebugLog("Getting TaskRunProcess", {
      processKeepAliveEnabled: this.processKeepAliveEnabled,
      hasPersistentProcess: !!this.persistentProcess,
      executionCount: this.executionCount,
      maxExecutionCount: this.processKeepAliveMaxExecutionCount,
      isWarmStart: opts.isWarmStart
    });
    if (!this.processKeepAliveEnabled) {
      this.sendDebugLog("Creating new TaskRunProcess (keep-alive disabled)");
      return this.createTaskRunProcess(opts);
    }
    if (this.shouldReusePersistentProcess()) {
      this.sendDebugLog("Reusing persistent TaskRunProcess", {
        executionCount: this.executionCount
      });
      return this.persistentProcess;
    }
    this.sendDebugLog("Creating new TaskRunProcess", {
      hadPersistentProcess: !!this.persistentProcess,
      reason: this.processKeepAliveEnabled ? "execution limit reached or unhealthy" : "keep-alive disabled"
    });
    const existingPersistentProcess = this.persistentProcess;
    if (existingPersistentProcess) {
      await this.cleanupProcess(existingPersistentProcess);
    }
    this.persistentProcess = this.createTaskRunProcess(opts);
    this.executionCount = 0;
    return this.persistentProcess;
  }
  /**
   * Returns a process after execution, handling keep-alive logic and cleanup
   */
  async returnProcess(process4) {
    this.sendDebugLog("Returning TaskRunProcess", {
      processKeepAliveEnabled: this.processKeepAliveEnabled,
      executionCount: this.executionCount,
      maxExecutionCount: this.processKeepAliveMaxExecutionCount
    });
    if (!this.processKeepAliveEnabled) {
      this.sendDebugLog("Keep-alive disabled, cleaning up process immediately");
      await process4.cleanup(true);
      return;
    }
    if (this.shouldKeepProcessAlive(process4)) {
      this.sendDebugLog("Keeping TaskRunProcess alive for next run", {
        executionCount: this.executionCount,
        maxExecutionCount: this.processKeepAliveMaxExecutionCount
      });
      await process4.cleanup(false);
      this.persistentProcess = process4;
      this.executionCount++;
    } else {
      this.sendDebugLog("Not keeping TaskRunProcess alive, cleaning up", {
        executionCount: this.executionCount,
        maxExecutionCount: this.processKeepAliveMaxExecutionCount,
        isHealthy: process4.isHealthy
      });
      await process4.cleanup(true);
    }
  }
  async suspendProcess(flush, process4) {
    if (this.persistentProcess) {
      if (process4) {
        if (this.persistentProcess.pid === process4.pid) {
          this.sendDebugLog("Suspending matching persistent TaskRunProcess (process provided)", {
            pid: process4.pid,
            flush
          });
          this.persistentProcess = null;
          this.executionCount = 0;
          await process4.suspend({ flush });
        } else {
          this.sendDebugLog("Suspending TaskRunProcess (does not match persistent process)", {
            pid: process4.pid,
            flush
          });
          await process4.suspend({ flush });
        }
      } else {
        this.sendDebugLog("Suspending persistent TaskRunProcess (no process provided)", {
          pid: this.persistentProcess.pid,
          flush
        });
        this.persistentProcess = null;
        this.executionCount = 0;
      }
    } else {
      if (process4) {
        this.sendDebugLog("Suspending non-persistent TaskRunProcess (process provided)", {
          pid: process4.pid,
          flush
        });
        await process4.suspend({ flush });
      } else {
        this.sendDebugLog("Suspending non-persistent TaskRunProcess (no process provided)", {
          flush
        });
      }
    }
  }
  /**
   * Handles process abort/kill scenarios
   */
  async handleProcessAbort(process4) {
    this.sendDebugLog("Handling process abort");
    if (this.persistentProcess?.pid === process4.pid) {
      this.persistentProcess = null;
      this.executionCount = 0;
    }
    await process4.cleanup(true);
  }
  async killProcess(process4) {
    this.sendDebugLog("Killing process");
    if (this.persistentProcess?.pid === process4.pid) {
      this.persistentProcess = null;
      this.executionCount = 0;
    }
    await this.cleanupProcess(process4);
  }
  /**
   * Forces cleanup of any persistent process
   */
  async cleanup() {
    if (this.persistentProcess) {
      this.sendDebugLog("cleanup() called");
      await this.cleanupProcess(this.persistentProcess);
    }
  }
  /**
   * Gets metrics about the provider state
   */
  get metrics() {
    return {
      processKeepAlive: {
        enabled: this.processKeepAliveEnabled,
        executionCount: this.executionCount,
        maxExecutionCount: this.processKeepAliveMaxExecutionCount,
        hasPersistentProcess: !!this.persistentProcess
      }
    };
  }
  createTaskRunProcess({ taskRunEnv, isWarmStart }) {
    const processEnv = this.buildProcessEnvironment(taskRunEnv);
    const taskRunProcess = new TaskRunProcess({
      workerManifest: this.workerManifest,
      env: processEnv,
      serverWorker: {
        id: "managed",
        contentHash: this.env.TRIGGER_CONTENT_HASH,
        version: this.env.TRIGGER_DEPLOYMENT_VERSION,
        engine: "V2"
      },
      machineResources: {
        cpu: Number(this.env.TRIGGER_MACHINE_CPU),
        memory: Number(this.env.TRIGGER_MACHINE_MEMORY)
      },
      isWarmStart
    }).initialize();
    return taskRunProcess;
  }
  buildProcessEnvironment(taskRunEnv) {
    return {
      ...taskRunEnv,
      ...this.env.gatherProcessEnv(),
      HEARTBEAT_INTERVAL_MS: String(this.env.TRIGGER_HEARTBEAT_INTERVAL_SECONDS * 1e3)
    };
  }
  shouldReusePersistentProcess() {
    this.sendDebugLog("Checking if persistent process should be reused", {
      executionCount: this.executionCount,
      maxExecutionCount: this.processKeepAliveMaxExecutionCount,
      pid: this.persistentProcess?.pid ?? "unknown",
      isBeingKilled: this.persistentProcess?.isBeingKilled ?? "unknown"
    });
    return !!this.persistentProcess && this.executionCount < this.processKeepAliveMaxExecutionCount && this.persistentProcess.isHealthy;
  }
  shouldKeepProcessAlive(process4) {
    return this.executionCount < this.processKeepAliveMaxExecutionCount && process4.isHealthy;
  }
  async cleanupProcess(taskRunProcess) {
    if (taskRunProcess && taskRunProcess.pid !== void 0) {
      this.sendDebugLog("Cleaning up TaskRunProcess", { pid: taskRunProcess.pid });
      await taskRunProcess.kill("SIGKILL").catch(() => {
      });
    }
  }
  sendDebugLog(message, properties) {
    this.logger.sendDebugLog({
      runId: void 0,
      // Provider doesn't have access to current run ID
      message: `[taskRunProcessProvider] ${message}`,
      properties
    });
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed/controller.js
var ManagedRunController = class {
  static {
    __name(this, "ManagedRunController");
  }
  env;
  workerManifest;
  httpClient;
  warmStartClient;
  socket;
  logger;
  taskRunProcessProvider;
  warmStartEnabled = true;
  warmStartCount = 0;
  restoreCount = 0;
  notificationCount = 0;
  lastNotificationAt = null;
  currentExecution = null;
  processKeepAliveEnabled;
  processKeepAliveMaxExecutionCount;
  constructor(opts) {
    const env = new RunnerEnv(opts.env);
    this.env = env;
    this.workerManifest = opts.workerManifest;
    this.processKeepAliveEnabled = opts.workerManifest.processKeepAlive?.enabled ?? false;
    this.processKeepAliveMaxExecutionCount = opts.workerManifest.processKeepAlive?.maxExecutionsPerProcess ?? 100;
    this.httpClient = new WorkloadHttpClient({
      workerApiUrl: this.workerApiUrl,
      runnerId: this.runnerId,
      deploymentId: env.TRIGGER_DEPLOYMENT_ID,
      deploymentVersion: env.TRIGGER_DEPLOYMENT_VERSION,
      projectRef: env.TRIGGER_PROJECT_REF
    });
    this.logger = new ManagedRunLogger({
      httpClient: this.httpClient,
      env
    });
    this.taskRunProcessProvider = new TaskRunProcessProvider({
      workerManifest: this.workerManifest,
      env: this.env,
      logger: this.logger,
      processKeepAliveEnabled: this.processKeepAliveEnabled,
      processKeepAliveMaxExecutionCount: this.processKeepAliveMaxExecutionCount
    });
    const properties = {
      ...env.raw,
      TRIGGER_POD_SCHEDULED_AT_MS: env.TRIGGER_POD_SCHEDULED_AT_MS.toISOString(),
      TRIGGER_DEQUEUED_AT_MS: env.TRIGGER_DEQUEUED_AT_MS.toISOString()
    };
    this.sendDebugLog({
      runId: env.TRIGGER_RUN_ID,
      message: "Creating run controller",
      properties
    });
    if (env.TRIGGER_WARM_START_URL) {
      this.warmStartClient = new WarmStartClient({
        apiUrl: new URL(env.TRIGGER_WARM_START_URL),
        controllerId: env.TRIGGER_WORKLOAD_CONTROLLER_ID,
        deploymentId: env.TRIGGER_DEPLOYMENT_ID,
        deploymentVersion: env.TRIGGER_DEPLOYMENT_VERSION,
        machineCpu: env.TRIGGER_MACHINE_CPU,
        machineMemory: env.TRIGGER_MACHINE_MEMORY
      });
    }
    this.socket = this.createSupervisorSocket();
    process.on("SIGTERM", async () => {
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "Received SIGTERM, stopping worker"
      });
      this.warmStartEnabled = false;
      this.warmStartClient?.abort();
    });
  }
  get metrics() {
    return {
      warmStartCount: this.warmStartCount,
      restoreCount: this.restoreCount,
      notificationCount: this.notificationCount,
      lastNotificationAt: this.lastNotificationAt,
      ...this.taskRunProcessProvider.metrics
    };
  }
  get runnerId() {
    return this.env.TRIGGER_RUNNER_ID;
  }
  get successExitCode() {
    return this.env.TRIGGER_SUCCESS_EXIT_CODE;
  }
  get failureExitCode() {
    return this.env.TRIGGER_FAILURE_EXIT_CODE;
  }
  get workerApiUrl() {
    return this.env.TRIGGER_SUPERVISOR_API_URL;
  }
  get workerInstanceName() {
    return this.env.TRIGGER_WORKER_INSTANCE_NAME;
  }
  subscribeToRunNotifications(runFriendlyId, snapshotFriendlyId) {
    this.socket.emit("run:start", {
      version: "1",
      run: {
        friendlyId: runFriendlyId
      },
      snapshot: {
        friendlyId: snapshotFriendlyId
      }
    });
  }
  unsubscribeFromRunNotifications(runFriendlyId, snapshotFriendlyId) {
    this.socket.emit("run:stop", {
      version: "1",
      run: {
        friendlyId: runFriendlyId
      },
      snapshot: {
        friendlyId: snapshotFriendlyId
      }
    });
  }
  get runFriendlyId() {
    return this.currentExecution?.runFriendlyId;
  }
  get snapshotFriendlyId() {
    return this.currentExecution?.currentSnapshotFriendlyId;
  }
  lockedRunExecution = null;
  async startRunExecution({ runFriendlyId, snapshotFriendlyId, dequeuedAt, podScheduledAt, isWarmStart, previousRunId }) {
    this.sendDebugLog({
      runId: runFriendlyId,
      message: "startAndExecuteRunAttempt()",
      properties: { previousRunId }
    });
    if (this.lockedRunExecution) {
      this.sendDebugLog({
        runId: runFriendlyId,
        message: "startAndExecuteRunAttempt: execution already locked"
      });
      return;
    }
    const execution = /* @__PURE__ */ __name(async () => {
      if (this.currentExecution && !this.currentExecution.canExecute) {
        this.sendDebugLog({
          runId: runFriendlyId,
          message: "killing existing execution before starting new run"
        });
        await this.currentExecution.shutdown().catch((error2) => {
          this.sendDebugLog({
            runId: runFriendlyId,
            message: "Error during execution shutdown",
            properties: { error: error2 instanceof Error ? error2.message : String(error2) }
          });
        });
        this.currentExecution = null;
      }
      this.socket.removeAllListeners("run:notify");
      if (!this.currentExecution || !this.currentExecution.canExecute) {
        this.currentExecution = new RunExecution({
          workerManifest: this.workerManifest,
          env: this.env,
          httpClient: this.httpClient,
          logger: this.logger,
          supervisorSocket: this.socket,
          taskRunProcessProvider: this.taskRunProcessProvider
        });
      }
      this.subscribeToRunNotifications(runFriendlyId, snapshotFriendlyId);
      await this.currentExecution.execute({
        runFriendlyId,
        snapshotFriendlyId,
        dequeuedAt,
        podScheduledAt,
        isWarmStart
      });
    }, "execution");
    this.lockedRunExecution = execution();
    const [error] = await tryCatch(this.lockedRunExecution);
    if (error) {
      this.sendDebugLog({
        runId: runFriendlyId,
        message: "Error during execution",
        properties: { error: error.message }
      });
    }
    const metrics = this.currentExecution?.metrics;
    if (metrics?.execution?.restoreCount) {
      this.restoreCount += metrics.execution.restoreCount;
    }
    this.lockedRunExecution = null;
    this.unsubscribeFromRunNotifications(runFriendlyId, snapshotFriendlyId);
    this.waitForNextRun();
  }
  waitForNextRunLock = false;
  /**
   *  This will eagerly create a new run execution. It will never throw, but may exit
   *  the process on any errors or when no runs are available after the configured duration.
   */
  async waitForNextRun() {
    if (!this.warmStartEnabled) {
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "waitForNextRun: warm starts disabled, shutting down"
      });
      this.exitProcess(this.successExitCode);
    }
    this.sendDebugLog({
      runId: this.runFriendlyId,
      message: "waitForNextRun()"
    });
    if (this.waitForNextRunLock) {
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "waitForNextRun: already in progress, skipping"
      });
      return;
    }
    if (this.lockedRunExecution) {
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "waitForNextRun: execution locked, skipping"
      });
      return;
    }
    this.waitForNextRunLock = true;
    const previousRunId = this.runFriendlyId;
    try {
      if (!this.warmStartClient) {
        this.sendDebugLog({
          runId: this.runFriendlyId,
          message: "waitForNextRun: warm starts disabled, shutting down"
        });
        this.exitProcess(this.successExitCode);
      }
      if (this.currentExecution?.taskRunEnv) {
        this.sendDebugLog({
          runId: this.runFriendlyId,
          message: "waitForNextRun: eagerly creating fresh execution for next run"
        });
        const previousTaskRunEnv = this.currentExecution.taskRunEnv;
        this.currentExecution = new RunExecution({
          workerManifest: this.workerManifest,
          env: this.env,
          httpClient: this.httpClient,
          logger: this.logger,
          supervisorSocket: this.socket,
          taskRunProcessProvider: this.taskRunProcessProvider
        });
        await this.currentExecution.prepareForExecution({
          taskRunEnv: previousTaskRunEnv
        });
      }
      const connect = await this.warmStartClient.connect();
      if (!connect.success) {
        this.sendDebugLog({
          runId: this.runFriendlyId,
          message: "waitForNextRun: failed to connect to warm start service",
          properties: {
            warmStartUrl: this.env.TRIGGER_WARM_START_URL,
            error: connect.error
          }
        });
        this.exitProcess(this.successExitCode);
      }
      const connectionTimeoutMs = connect.data.connectionTimeoutMs ?? this.env.TRIGGER_WARM_START_CONNECTION_TIMEOUT_MS;
      const keepaliveMs = connect.data.keepaliveMs ?? this.env.TRIGGER_WARM_START_KEEPALIVE_MS;
      const warmStartConfig = {
        connectionTimeoutMs,
        keepaliveMs
      };
      this.sendDebugLog({
        runId: previousRunId,
        message: "waitForNextRun: connected to warm start service",
        properties: warmStartConfig
      });
      if (!connectionTimeoutMs || !keepaliveMs) {
        this.sendDebugLog({
          runId: previousRunId,
          message: "waitForNextRun: warm starts disabled after connect",
          properties: warmStartConfig
        });
        this.exitProcess(this.successExitCode);
      }
      const nextRun = await this.warmStartClient.warmStart({
        workerInstanceName: this.workerInstanceName,
        connectionTimeoutMs,
        keepaliveMs
      });
      if (!nextRun) {
        this.sendDebugLog({
          runId: previousRunId,
          message: "waitForNextRun: warm start failed, shutting down",
          properties: warmStartConfig
        });
        this.exitProcess(this.successExitCode);
      }
      this.warmStartCount++;
      this.sendDebugLog({
        runId: previousRunId,
        message: "waitForNextRun: got next run",
        properties: {
          ...warmStartConfig,
          nextRunId: nextRun.run.friendlyId
        }
      });
      this.startRunExecution({
        runFriendlyId: nextRun.run.friendlyId,
        snapshotFriendlyId: nextRun.snapshot.friendlyId,
        dequeuedAt: nextRun.dequeuedAt,
        isWarmStart: true,
        previousRunId
      }).finally(() => {
      });
    } catch (error) {
      this.sendDebugLog({
        runId: previousRunId,
        message: "waitForNextRun: unexpected error",
        properties: { error: error instanceof Error ? error.message : String(error) }
      });
      this.exitProcess(this.failureExitCode);
    } finally {
      this.waitForNextRunLock = false;
    }
  }
  exitProcess(code) {
    this.sendDebugLog({
      runId: this.runFriendlyId,
      message: "Exiting process",
      properties: { code }
    });
    this.currentExecution?.kill().catch(() => {
    });
    this.taskRunProcessProvider.cleanup().catch(() => {
    });
    process.exit(code);
  }
  createSupervisorSocket() {
    const wsUrl = new URL("/workload", this.workerApiUrl);
    const socket = lookup(wsUrl.href, {
      transports: ["websocket"],
      extraHeaders: {
        [WORKLOAD_HEADERS.DEPLOYMENT_ID]: this.env.TRIGGER_DEPLOYMENT_ID,
        [WORKLOAD_HEADERS.RUNNER_ID]: this.env.TRIGGER_RUNNER_ID
      }
    });
    socket.on("connect", () => {
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "Socket connected to supervisor"
      });
    });
    socket.on("connect_error", (error) => {
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "Socket connection error",
        properties: { error: error instanceof Error ? error.message : String(error) }
      });
    });
    socket.on("disconnect", async (reason, description) => {
      const parseDescription = /* @__PURE__ */ __name(() => {
        if (!description) {
          return void 0;
        }
        if (description instanceof Error) {
          return {
            description: description.toString()
          };
        }
        return {
          description: description.description,
          context: description.context ? String(description.context) : void 0
        };
      }, "parseDescription");
      if (this.currentExecution) {
        const currentEnv = {
          workerInstanceName: this.env.TRIGGER_WORKER_INSTANCE_NAME,
          runnerId: this.env.TRIGGER_RUNNER_ID,
          supervisorApiUrl: this.env.TRIGGER_SUPERVISOR_API_URL
        };
        const result = await this.currentExecution.processEnvOverrides("socket disconnected", true);
        const newEnv = {
          workerInstanceName: this.env.TRIGGER_WORKER_INSTANCE_NAME,
          runnerId: this.env.TRIGGER_RUNNER_ID,
          supervisorApiUrl: this.env.TRIGGER_SUPERVISOR_API_URL
        };
        this.sendDebugLog({
          runId: this.runFriendlyId,
          message: "Socket disconnected from supervisor - processed env overrides",
          properties: { reason, ...parseDescription(), currentEnv, newEnv }
        });
        if (!result) {
          return;
        }
        if (result.runnerIdChanged) {
          this.sendDebugLog({
            runId: this.runFriendlyId,
            message: "Runner ID changed - restore detected",
            properties: {
              supervisorChanged: result.supervisorChanged
            }
          });
          if (!result.supervisorChanged) {
            return;
          }
          this.sendDebugLog({
            runId: this.runFriendlyId,
            message: "Supervisor URL changed - creating new socket connection"
          });
          socket.removeAllListeners();
          socket.disconnect();
          this.socket = this.createSupervisorSocket();
          if (this.runFriendlyId && this.snapshotFriendlyId) {
            this.subscribeToRunNotifications(this.runFriendlyId, this.snapshotFriendlyId);
          }
        }
        return;
      }
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "Socket disconnected from supervisor",
        properties: { reason, ...parseDescription() }
      });
    });
    return socket;
  }
  start() {
    this.sendDebugLog({
      runId: this.runFriendlyId,
      message: "Starting up"
    });
    if (this.env.TRIGGER_RUN_ID && this.env.TRIGGER_SNAPSHOT_ID) {
      this.startRunExecution({
        runFriendlyId: this.env.TRIGGER_RUN_ID,
        snapshotFriendlyId: this.env.TRIGGER_SNAPSHOT_ID,
        dequeuedAt: this.env.TRIGGER_DEQUEUED_AT_MS,
        podScheduledAt: this.env.TRIGGER_POD_SCHEDULED_AT_MS
      }).finally(() => {
      });
      return;
    }
    this.waitForNextRun();
    return;
  }
  async cancelRunsAndExitProcess() {
    this.sendDebugLog({
      runId: this.runFriendlyId,
      message: "Shutting down"
    });
    const [error] = await tryCatch(this.currentExecution?.cancel());
    if (error) {
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "Error during shutdown",
        properties: { error: String(error) }
      });
    }
    const [cleanupError] = await tryCatch(this.taskRunProcessProvider.cleanup());
    if (cleanupError) {
      this.sendDebugLog({
        runId: this.runFriendlyId,
        message: "Error during task run process provider cleanup",
        properties: { error: String(cleanupError) }
      });
    }
    this.socket.close();
    this.exitProcess(this.successExitCode);
  }
  sendDebugLog(opts) {
    this.logger.sendDebugLog({
      ...opts,
      message: `[controller] ${opts.message}`,
      properties: {
        ...opts.properties,
        runnerWarmStartCount: this.warmStartCount,
        runnerRestoreCount: this.restoreCount
      }
    });
  }
};

// ../../.npm/_npx/f51a09bd0abf5f10/node_modules/trigger.dev/dist/esm/entryPoints/managed-run-controller.js
logger.loggerLevel = "debug";
var manifest = await readJSONFile("./index.json");
var workerManifest = WorkerManifest.parse(manifest);
new ManagedRunController({
  workerManifest,
  env: o
}).start();
/*! Bundled license information:

evt/lib/types/lib.dom.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
   
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
   
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=managed-run-controller.mjs.map
